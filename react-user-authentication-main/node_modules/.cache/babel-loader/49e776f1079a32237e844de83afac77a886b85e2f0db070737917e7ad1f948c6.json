{"ast":null,"code":"// src/utils/CryptoUtils.ts\nimport CryptoJS from \"crypto-js/core.js\";\nimport sha256 from \"crypto-js/sha256.js\";\nimport Base64 from \"crypto-js/enc-base64.js\";\nimport Utf8 from \"crypto-js/enc-utf8.js\";\n\n// src/utils/Logger.ts\nvar nopLogger = {\n  debug: () => void 0,\n  info: () => void 0,\n  warn: () => void 0,\n  error: () => void 0\n};\nvar level;\nvar logger;\nvar Log = /* @__PURE__ */(Log2 => {\n  Log2[Log2[\"NONE\"] = 0] = \"NONE\";\n  Log2[Log2[\"ERROR\"] = 1] = \"ERROR\";\n  Log2[Log2[\"WARN\"] = 2] = \"WARN\";\n  Log2[Log2[\"INFO\"] = 3] = \"INFO\";\n  Log2[Log2[\"DEBUG\"] = 4] = \"DEBUG\";\n  return Log2;\n})(Log || {});\n(Log2 => {\n  function reset() {\n    level = 3 /* INFO */;\n    logger = nopLogger;\n  }\n  Log2.reset = reset;\n  function setLevel(value) {\n    if (!(0 /* NONE */ <= value && value <= 4 /* DEBUG */)) {\n      throw new Error(\"Invalid log level\");\n    }\n    level = value;\n  }\n  Log2.setLevel = setLevel;\n  function setLogger(value) {\n    logger = value;\n  }\n  Log2.setLogger = setLogger;\n})(Log || (Log = {}));\nvar Logger = class {\n  constructor(_name) {\n    this._name = _name;\n  }\n  debug() {\n    if (level >= 4 /* DEBUG */) {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      logger.debug(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  info() {\n    if (level >= 3 /* INFO */) {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      logger.info(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  warn() {\n    if (level >= 2 /* WARN */) {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      logger.warn(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  error() {\n    if (level >= 1 /* ERROR */) {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      logger.error(Logger._format(this._name, this._method), ...args);\n    }\n  }\n  throw(err) {\n    this.error(err);\n    throw err;\n  }\n  create(method) {\n    const methodLogger = Object.create(this);\n    methodLogger._method = method;\n    methodLogger.debug(\"begin\");\n    return methodLogger;\n  }\n  static createStatic(name, staticMethod) {\n    const staticLogger = new Logger(`${name}.${staticMethod}`);\n    staticLogger.debug(\"begin\");\n    return staticLogger;\n  }\n  static _format(name, method) {\n    const prefix = `[${name}]`;\n    return method ? `${prefix} ${method}:` : prefix;\n  }\n  static debug(name) {\n    if (level >= 4 /* DEBUG */) {\n      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n      logger.debug(Logger._format(name), ...args);\n    }\n  }\n  static info(name) {\n    if (level >= 3 /* INFO */) {\n      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n        args[_key6 - 1] = arguments[_key6];\n      }\n      logger.info(Logger._format(name), ...args);\n    }\n  }\n  static warn(name) {\n    if (level >= 2 /* WARN */) {\n      for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        args[_key7 - 1] = arguments[_key7];\n      }\n      logger.warn(Logger._format(name), ...args);\n    }\n  }\n  static error(name) {\n    if (level >= 1 /* ERROR */) {\n      for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        args[_key8 - 1] = arguments[_key8];\n      }\n      logger.error(Logger._format(name), ...args);\n    }\n  }\n};\nLog.reset();\n\n// src/utils/CryptoUtils.ts\nvar UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\nvar CryptoUtils = class {\n  static _randomWord() {\n    return CryptoJS.lib.WordArray.random(1).words[0];\n  }\n  static generateUUIDv4() {\n    const uuid = UUID_V4_TEMPLATE.replace(/[018]/g, c => (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16));\n    return uuid.replace(/-/g, \"\");\n  }\n  static generateCodeVerifier() {\n    return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n  }\n  static generateCodeChallenge(code_verifier) {\n    try {\n      const hashed = sha256(code_verifier);\n      return Base64.stringify(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } catch (err) {\n      Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n      throw err;\n    }\n  }\n  static generateBasicAuth(client_id, client_secret) {\n    const basicAuth = Utf8.parse([client_id, client_secret].join(\":\"));\n    return Base64.stringify(basicAuth);\n  }\n};\n\n// src/utils/Event.ts\nvar Event = class {\n  constructor(_name) {\n    this._name = _name;\n    this._logger = new Logger(`Event('${this._name}')`);\n    this._callbacks = [];\n  }\n  addHandler(cb) {\n    this._callbacks.push(cb);\n    return () => this.removeHandler(cb);\n  }\n  removeHandler(cb) {\n    const idx = this._callbacks.lastIndexOf(cb);\n    if (idx >= 0) {\n      this._callbacks.splice(idx, 1);\n    }\n  }\n  raise() {\n    for (var _len9 = arguments.length, ev = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      ev[_key9] = arguments[_key9];\n    }\n    this._logger.debug(\"raise:\", ...ev);\n    for (const cb of this._callbacks) {\n      void cb(...ev);\n    }\n  }\n};\n\n// src/utils/JwtUtils.ts\nimport jwt_decode from \"jwt-decode\";\nvar JwtUtils = class {\n  static decode(token) {\n    try {\n      return jwt_decode(token);\n    } catch (err) {\n      Logger.error(\"JwtUtils.decode\", err);\n      throw err;\n    }\n  }\n};\n\n// src/utils/PopupUtils.ts\nvar PopupUtils = class {\n  static center(_ref) {\n    let {\n      ...features\n    } = _ref;\n    var _a, _b, _c;\n    if (features.width == null) features.width = (_a = [800, 720, 600, 480].find(width => width <= window.outerWidth / 1.618)) != null ? _a : 360;\n    (_b = features.left) != null ? _b : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n    if (features.height != null) (_c = features.top) != null ? _c : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n    return features;\n  }\n  static serialize(features) {\n    return Object.entries(features).filter(_ref2 => {\n      let [, value] = _ref2;\n      return value != null;\n    }).map(_ref3 => {\n      let [key, value] = _ref3;\n      return `${key}=${typeof value !== \"boolean\" ? value : value ? \"yes\" : \"no\"}`;\n    }).join(\",\");\n  }\n};\n\n// src/utils/Timer.ts\nvar Timer = class extends Event {\n  constructor() {\n    super(...arguments);\n    this._logger = new Logger(`Timer('${this._name}')`);\n    this._timerHandle = null;\n    this._expiration = 0;\n    this._callback = () => {\n      const diff = this._expiration - Timer.getEpochTime();\n      this._logger.debug(\"timer completes in\", diff);\n      if (this._expiration <= Timer.getEpochTime()) {\n        this.cancel();\n        super.raise();\n      }\n    };\n  }\n  static getEpochTime() {\n    return Math.floor(Date.now() / 1e3);\n  }\n  init(durationInSeconds) {\n    const logger2 = this._logger.create(\"init\");\n    durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n    const expiration = Timer.getEpochTime() + durationInSeconds;\n    if (this.expiration === expiration && this._timerHandle) {\n      logger2.debug(\"skipping since already initialized for expiration at\", this.expiration);\n      return;\n    }\n    this.cancel();\n    logger2.debug(\"using duration\", durationInSeconds);\n    this._expiration = expiration;\n    const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n    this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);\n  }\n  get expiration() {\n    return this._expiration;\n  }\n  cancel() {\n    this._logger.create(\"cancel\");\n    if (this._timerHandle) {\n      clearInterval(this._timerHandle);\n      this._timerHandle = null;\n    }\n  }\n};\n\n// src/utils/UrlUtils.ts\nvar UrlUtils = class {\n  static readParams(url) {\n    let responseMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"query\";\n    if (!url) throw new TypeError(\"Invalid URL\");\n    const parsedUrl = new URL(url, window.location.origin);\n    const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n    return new URLSearchParams(params.slice(1));\n  }\n};\n\n// src/errors/ErrorResponse.ts\nvar ErrorResponse = class extends Error {\n  constructor(args, form) {\n    var _a, _b, _c;\n    super(args.error_description || args.error || \"\");\n    this.form = form;\n    this.name = \"ErrorResponse\";\n    if (!args.error) {\n      Logger.error(\"ErrorResponse\", \"No error passed\");\n      throw new Error(\"No error passed\");\n    }\n    this.error = args.error;\n    this.error_description = (_a = args.error_description) != null ? _a : null;\n    this.error_uri = (_b = args.error_uri) != null ? _b : null;\n    this.state = args.userState;\n    this.session_state = (_c = args.session_state) != null ? _c : null;\n  }\n};\n\n// src/errors/ErrorTimeout.ts\nvar ErrorTimeout = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ErrorTimeout\";\n  }\n};\n\n// src/AccessTokenEvents.ts\nvar AccessTokenEvents = class {\n  constructor(args) {\n    this._logger = new Logger(\"AccessTokenEvents\");\n    this._expiringTimer = new Timer(\"Access token expiring\");\n    this._expiredTimer = new Timer(\"Access token expired\");\n    this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n  }\n  load(container) {\n    const logger2 = this._logger.create(\"load\");\n    if (container.access_token && container.expires_in !== void 0) {\n      const duration = container.expires_in;\n      logger2.debug(\"access token present, remaining duration:\", duration);\n      if (duration > 0) {\n        let expiring = duration - this._expiringNotificationTimeInSeconds;\n        if (expiring <= 0) {\n          expiring = 1;\n        }\n        logger2.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n        this._expiringTimer.init(expiring);\n      } else {\n        logger2.debug(\"canceling existing expiring timer because we're past expiration.\");\n        this._expiringTimer.cancel();\n      }\n      const expired = duration + 1;\n      logger2.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n      this._expiredTimer.init(expired);\n    } else {\n      this._expiringTimer.cancel();\n      this._expiredTimer.cancel();\n    }\n  }\n  unload() {\n    this._logger.debug(\"unload: canceling existing access token timers\");\n    this._expiringTimer.cancel();\n    this._expiredTimer.cancel();\n  }\n  addAccessTokenExpiring(cb) {\n    return this._expiringTimer.addHandler(cb);\n  }\n  removeAccessTokenExpiring(cb) {\n    this._expiringTimer.removeHandler(cb);\n  }\n  addAccessTokenExpired(cb) {\n    return this._expiredTimer.addHandler(cb);\n  }\n  removeAccessTokenExpired(cb) {\n    this._expiredTimer.removeHandler(cb);\n  }\n};\n\n// src/CheckSessionIFrame.ts\nvar CheckSessionIFrame = class {\n  constructor(_callback, _client_id, url, _intervalInSeconds, _stopOnError) {\n    this._callback = _callback;\n    this._client_id = _client_id;\n    this._intervalInSeconds = _intervalInSeconds;\n    this._stopOnError = _stopOnError;\n    this._logger = new Logger(\"CheckSessionIFrame\");\n    this._timer = null;\n    this._session_state = null;\n    this._message = e => {\n      if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {\n        if (e.data === \"error\") {\n          this._logger.error(\"error message from check session op iframe\");\n          if (this._stopOnError) {\n            this.stop();\n          }\n        } else if (e.data === \"changed\") {\n          this._logger.debug(\"changed message from check session op iframe\");\n          this.stop();\n          void this._callback();\n        } else {\n          this._logger.debug(e.data + \" message from check session op iframe\");\n        }\n      }\n    };\n    const parsedUrl = new URL(url);\n    this._frame_origin = parsedUrl.origin;\n    this._frame = window.document.createElement(\"iframe\");\n    this._frame.style.visibility = \"hidden\";\n    this._frame.style.position = \"fixed\";\n    this._frame.style.left = \"-1000px\";\n    this._frame.style.top = \"0\";\n    this._frame.width = \"0\";\n    this._frame.height = \"0\";\n    this._frame.src = parsedUrl.href;\n  }\n  load() {\n    return new Promise(resolve => {\n      this._frame.onload = () => {\n        resolve();\n      };\n      window.document.body.appendChild(this._frame);\n      window.addEventListener(\"message\", this._message, false);\n    });\n  }\n  start(session_state) {\n    if (this._session_state === session_state) {\n      return;\n    }\n    this._logger.create(\"start\");\n    this.stop();\n    this._session_state = session_state;\n    const send = () => {\n      if (!this._frame.contentWindow || !this._session_state) {\n        return;\n      }\n      this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n    };\n    send();\n    this._timer = setInterval(send, this._intervalInSeconds * 1e3);\n  }\n  stop() {\n    this._logger.create(\"stop\");\n    this._session_state = null;\n    if (this._timer) {\n      clearInterval(this._timer);\n      this._timer = null;\n    }\n  }\n};\n\n// src/InMemoryWebStorage.ts\nvar InMemoryWebStorage = class {\n  constructor() {\n    this._logger = new Logger(\"InMemoryWebStorage\");\n    this._data = {};\n  }\n  clear() {\n    this._logger.create(\"clear\");\n    this._data = {};\n  }\n  getItem(key) {\n    this._logger.create(`getItem('${key}')`);\n    return this._data[key];\n  }\n  setItem(key, value) {\n    this._logger.create(`setItem('${key}')`);\n    this._data[key] = value;\n  }\n  removeItem(key) {\n    this._logger.create(`removeItem('${key}')`);\n    delete this._data[key];\n  }\n  get length() {\n    return Object.getOwnPropertyNames(this._data).length;\n  }\n  key(index) {\n    return Object.getOwnPropertyNames(this._data)[index];\n  }\n};\n\n// src/JsonService.ts\nvar JsonService = class {\n  constructor() {\n    let additionalContentTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let _jwtHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    this._jwtHandler = _jwtHandler;\n    this._logger = new Logger(\"JsonService\");\n    this._contentTypes = [];\n    this._contentTypes.push(...additionalContentTypes, \"application/json\");\n    if (_jwtHandler) {\n      this._contentTypes.push(\"application/jwt\");\n    }\n  }\n  async fetchWithTimeout(input) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      timeoutInSeconds,\n      ...initFetch\n    } = init;\n    if (!timeoutInSeconds) {\n      return await fetch(input, initFetch);\n    }\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);\n    try {\n      const response = await fetch(input, {\n        ...init,\n        signal: controller.signal\n      });\n      return response;\n    } catch (err) {\n      if (err instanceof DOMException && err.name === \"AbortError\") {\n        throw new ErrorTimeout(\"Network timed out\");\n      }\n      throw err;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n  async getJson(url) {\n    let {\n      token,\n      credentials\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const logger2 = this._logger.create(\"getJson\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \")\n    };\n    if (token) {\n      logger2.debug(\"token passed, setting Authorization header\");\n      headers[\"Authorization\"] = \"Bearer \" + token;\n    }\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, {\n        method: \"GET\",\n        headers,\n        credentials\n      });\n    } catch (err) {\n      logger2.error(\"Network Error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n      logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`));\n    }\n    if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith(\"application/jwt\"))) {\n      return await this._jwtHandler(await response.text());\n    }\n    let json;\n    try {\n      json = await response.json();\n    } catch (err) {\n      logger2.error(\"Error parsing JSON response\", err);\n      if (response.ok) throw err;\n      throw new Error(`${response.statusText} (${response.status})`);\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  async postForm(url, _ref4) {\n    let {\n      body,\n      basicAuth,\n      timeoutInSeconds,\n      initCredentials\n    } = _ref4;\n    const logger2 = this._logger.create(\"postForm\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \"),\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    };\n    if (basicAuth !== void 0) {\n      headers[\"Authorization\"] = \"Basic \" + basicAuth;\n    }\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, {\n        method: \"POST\",\n        headers,\n        body,\n        timeoutInSeconds,\n        credentials: initCredentials\n      });\n    } catch (err) {\n      logger2.error(\"Network error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n      throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`);\n    }\n    const responseText = await response.text();\n    let json = {};\n    if (responseText) {\n      try {\n        json = JSON.parse(responseText);\n      } catch (err) {\n        logger2.error(\"Error parsing JSON response\", err);\n        if (response.ok) throw err;\n        throw new Error(`${response.statusText} (${response.status})`);\n      }\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json, body);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n};\n\n// src/MetadataService.ts\nvar MetadataService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"MetadataService\");\n    this._jsonService = new JsonService([\"application/jwk-set+json\"]);\n    this._signingKeys = null;\n    this._metadata = null;\n    this._metadataUrl = this._settings.metadataUrl;\n    if (this._settings.signingKeys) {\n      this._logger.debug(\"using signingKeys from settings\");\n      this._signingKeys = this._settings.signingKeys;\n    }\n    if (this._settings.metadata) {\n      this._logger.debug(\"using metadata from settings\");\n      this._metadata = this._settings.metadata;\n    }\n    if (this._settings.fetchRequestCredentials) {\n      this._logger.debug(\"using fetchRequestCredentials from settings\");\n      this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n    }\n  }\n  resetSigningKeys() {\n    this._signingKeys = null;\n  }\n  async getMetadata() {\n    const logger2 = this._logger.create(\"getMetadata\");\n    if (this._metadata) {\n      logger2.debug(\"using cached values\");\n      return this._metadata;\n    }\n    if (!this._metadataUrl) {\n      logger2.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n      throw null;\n    }\n    logger2.debug(\"getting metadata from\", this._metadataUrl);\n    const metadata = await this._jsonService.getJson(this._metadataUrl, {\n      credentials: this._fetchRequestCredentials\n    });\n    logger2.debug(\"merging remote JSON with seed metadata\");\n    this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);\n    return this._metadata;\n  }\n  getIssuer() {\n    return this._getMetadataProperty(\"issuer\");\n  }\n  getAuthorizationEndpoint() {\n    return this._getMetadataProperty(\"authorization_endpoint\");\n  }\n  getUserInfoEndpoint() {\n    return this._getMetadataProperty(\"userinfo_endpoint\");\n  }\n  getTokenEndpoint() {\n    let optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this._getMetadataProperty(\"token_endpoint\", optional);\n  }\n  getCheckSessionIframe() {\n    return this._getMetadataProperty(\"check_session_iframe\", true);\n  }\n  getEndSessionEndpoint() {\n    return this._getMetadataProperty(\"end_session_endpoint\", true);\n  }\n  getRevocationEndpoint() {\n    let optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this._getMetadataProperty(\"revocation_endpoint\", optional);\n  }\n  getKeysEndpoint() {\n    let optional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return this._getMetadataProperty(\"jwks_uri\", optional);\n  }\n  async _getMetadataProperty(name) {\n    let optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const logger2 = this._logger.create(`_getMetadataProperty('${name}')`);\n    const metadata = await this.getMetadata();\n    logger2.debug(\"resolved\");\n    if (metadata[name] === void 0) {\n      if (optional === true) {\n        logger2.warn(\"Metadata does not contain optional property\");\n        return void 0;\n      }\n      logger2.throw(new Error(\"Metadata does not contain property \" + name));\n    }\n    return metadata[name];\n  }\n  async getSigningKeys() {\n    const logger2 = this._logger.create(\"getSigningKeys\");\n    if (this._signingKeys) {\n      logger2.debug(\"returning signingKeys from cache\");\n      return this._signingKeys;\n    }\n    const jwks_uri = await this.getKeysEndpoint(false);\n    logger2.debug(\"got jwks_uri\", jwks_uri);\n    const keySet = await this._jsonService.getJson(jwks_uri);\n    logger2.debug(\"got key set\", keySet);\n    if (!Array.isArray(keySet.keys)) {\n      logger2.throw(new Error(\"Missing keys on keyset\"));\n      throw null;\n    }\n    this._signingKeys = keySet.keys;\n    return this._signingKeys;\n  }\n};\n\n// src/WebStorageStateStore.ts\nvar WebStorageStateStore = class {\n  constructor() {\n    let {\n      prefix = \"oidc.\",\n      store = localStorage\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._logger = new Logger(\"WebStorageStateStore\");\n    this._store = store;\n    this._prefix = prefix;\n  }\n  async set(key, value) {\n    this._logger.create(`set('${key}')`);\n    key = this._prefix + key;\n    await this._store.setItem(key, value);\n  }\n  async get(key) {\n    this._logger.create(`get('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    return item;\n  }\n  async remove(key) {\n    this._logger.create(`remove('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    await this._store.removeItem(key);\n    return item;\n  }\n  async getAllKeys() {\n    this._logger.create(\"getAllKeys\");\n    const len = await this._store.length;\n    const keys = [];\n    for (let index = 0; index < len; index++) {\n      const key = await this._store.key(index);\n      if (key && key.indexOf(this._prefix) === 0) {\n        keys.push(key.substr(this._prefix.length));\n      }\n    }\n    return keys;\n  }\n};\n\n// src/OidcClientSettings.ts\nvar DefaultResponseType = \"code\";\nvar DefaultScope = \"openid\";\nvar DefaultClientAuthentication = \"client_secret_post\";\nvar DefaultResponseMode = \"query\";\nvar DefaultStaleStateAgeInSeconds = 60 * 15;\nvar DefaultClockSkewInSeconds = 60 * 5;\nvar OidcClientSettingsStore = class {\n  constructor(_ref5) {\n    let {\n      authority,\n      metadataUrl,\n      metadata,\n      signingKeys,\n      metadataSeed,\n      client_id,\n      client_secret,\n      response_type = DefaultResponseType,\n      scope = DefaultScope,\n      redirect_uri,\n      post_logout_redirect_uri,\n      client_authentication = DefaultClientAuthentication,\n      prompt,\n      display,\n      max_age,\n      ui_locales,\n      acr_values,\n      resource,\n      response_mode = DefaultResponseMode,\n      filterProtocolClaims = true,\n      loadUserInfo = false,\n      staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n      clockSkewInSeconds = DefaultClockSkewInSeconds,\n      userInfoJwtIssuer = \"OP\",\n      mergeClaims = false,\n      stateStore,\n      refreshTokenCredentials,\n      revokeTokenAdditionalContentTypes,\n      fetchRequestCredentials,\n      extraQueryParams = {},\n      extraTokenParams = {}\n    } = _ref5;\n    this.authority = authority;\n    if (metadataUrl) {\n      this.metadataUrl = metadataUrl;\n    } else {\n      this.metadataUrl = authority;\n      if (authority) {\n        if (!this.metadataUrl.endsWith(\"/\")) {\n          this.metadataUrl += \"/\";\n        }\n        this.metadataUrl += \".well-known/openid-configuration\";\n      }\n    }\n    this.metadata = metadata;\n    this.metadataSeed = metadataSeed;\n    this.signingKeys = signingKeys;\n    this.client_id = client_id;\n    this.client_secret = client_secret;\n    this.response_type = response_type;\n    this.scope = scope;\n    this.redirect_uri = redirect_uri;\n    this.post_logout_redirect_uri = post_logout_redirect_uri;\n    this.client_authentication = client_authentication;\n    this.prompt = prompt;\n    this.display = display;\n    this.max_age = max_age;\n    this.ui_locales = ui_locales;\n    this.acr_values = acr_values;\n    this.resource = resource;\n    this.response_mode = response_mode;\n    this.filterProtocolClaims = !!filterProtocolClaims;\n    this.loadUserInfo = !!loadUserInfo;\n    this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n    this.clockSkewInSeconds = clockSkewInSeconds;\n    this.userInfoJwtIssuer = userInfoJwtIssuer;\n    this.mergeClaims = !!mergeClaims;\n    this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n    if (fetchRequestCredentials && refreshTokenCredentials) {\n      console.warn(\"Both fetchRequestCredentials and refreshTokenCredentials is set. Only fetchRequestCredentials will be used.\");\n    }\n    this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : refreshTokenCredentials ? refreshTokenCredentials : \"same-origin\";\n    if (stateStore) {\n      this.stateStore = stateStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n      this.stateStore = new WebStorageStateStore({\n        store\n      });\n    }\n    this.extraQueryParams = extraQueryParams;\n    this.extraTokenParams = extraTokenParams;\n  }\n};\n\n// src/UserInfoService.ts\nvar UserInfoService = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"UserInfoService\");\n    this._getClaimsFromJwt = async responseText => {\n      const logger2 = this._logger.create(\"_getClaimsFromJwt\");\n      try {\n        const payload = JwtUtils.decode(responseText);\n        logger2.debug(\"JWT decoding successful\");\n        return payload;\n      } catch (err) {\n        logger2.error(\"Error parsing JWT response\");\n        throw err;\n      }\n    };\n    this._jsonService = new JsonService(void 0, this._getClaimsFromJwt);\n  }\n  async getClaims(token) {\n    const logger2 = this._logger.create(\"getClaims\");\n    if (!token) {\n      this._logger.throw(new Error(\"No token passed\"));\n    }\n    const url = await this._metadataService.getUserInfoEndpoint();\n    logger2.debug(\"got userinfo url\", url);\n    const claims = await this._jsonService.getJson(url, {\n      token,\n      credentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got claims\", claims);\n    return claims;\n  }\n};\n\n// src/TokenClient.ts\nvar TokenClient = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"TokenClient\");\n    this._jsonService = new JsonService(this._settings.revokeTokenAdditionalContentTypes);\n  }\n  async exchangeCode(_ref6) {\n    let {\n      grant_type = \"authorization_code\",\n      redirect_uri = this._settings.redirect_uri,\n      client_id = this._settings.client_id,\n      client_secret = this._settings.client_secret,\n      ...args\n    } = _ref6;\n    const logger2 = this._logger.create(\"exchangeCode\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!redirect_uri) {\n      logger2.throw(new Error(\"A redirect_uri is required\"));\n    }\n    if (!args.code) {\n      logger2.throw(new Error(\"A code is required\"));\n    }\n    if (!args.code_verifier) {\n      logger2.throw(new Error(\"A code_verifier is required\"));\n    }\n    const params = new URLSearchParams({\n      grant_type,\n      redirect_uri\n    });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      initCredentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  async exchangeCredentials(_ref7) {\n    let {\n      grant_type = \"password\",\n      client_id = this._settings.client_id,\n      client_secret = this._settings.client_secret,\n      scope = this._settings.scope,\n      username,\n      password\n    } = _ref7;\n    const logger2 = this._logger.create(\"exchangeCredentials\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    const params = new URLSearchParams({\n      grant_type,\n      username,\n      password,\n      scope\n    });\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      initCredentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  async exchangeRefreshToken(_ref8) {\n    let {\n      grant_type = \"refresh_token\",\n      client_id = this._settings.client_id,\n      client_secret = this._settings.client_secret,\n      timeoutInSeconds,\n      ...args\n    } = _ref8;\n    const logger2 = this._logger.create(\"exchangeRefreshToken\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!args.refresh_token) {\n      logger2.throw(new Error(\"A refresh_token is required\"));\n    }\n    const params = new URLSearchParams({\n      grant_type\n    });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    let basicAuth;\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        if (!client_secret) {\n          logger2.throw(new Error(\"A client_secret is required\"));\n          throw null;\n        }\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n    }\n    const url = await this._metadataService.getTokenEndpoint(false);\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      timeoutInSeconds,\n      initCredentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  async revoke(args) {\n    var _a;\n    const logger2 = this._logger.create(\"revoke\");\n    if (!args.token) {\n      logger2.throw(new Error(\"A token is required\"));\n    }\n    const url = await this._metadataService.getRevocationEndpoint(false);\n    logger2.debug(`got revocation endpoint, revoking ${(_a = args.token_type_hint) != null ? _a : \"default token type\"}`);\n    const params = new URLSearchParams();\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    params.set(\"client_id\", this._settings.client_id);\n    if (this._settings.client_secret) {\n      params.set(\"client_secret\", this._settings.client_secret);\n    }\n    await this._jsonService.postForm(url, {\n      body: params\n    });\n    logger2.debug(\"got response\");\n  }\n};\n\n// src/ResponseValidator.ts\nvar ProtocolClaims = [\"iss\", \"aud\", \"exp\", \"nbf\", \"iat\", \"jti\", \"auth_time\", \"nonce\", \"acr\", \"amr\", \"azp\", \"at_hash\"];\nvar ResponseValidator = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"ResponseValidator\");\n    this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n    this._tokenClient = new TokenClient(this._settings, this._metadataService);\n  }\n  async validateSigninResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSigninResponse\");\n    this._processSigninState(response, state);\n    logger2.debug(\"state processed\");\n    await this._processCode(response, state);\n    logger2.debug(\"code processed\");\n    if (response.isOpenId) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, state == null ? void 0 : state.skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateCredentialsResponse(response, skipUserInfo) {\n    const logger2 = this._logger.create(\"validateCredentialsResponse\");\n    if (response.isOpenId) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateRefreshResponse(response, state) {\n    var _a, _b;\n    const logger2 = this._logger.create(\"validateRefreshResponse\");\n    response.userState = state.data;\n    (_a = response.session_state) != null ? _a : response.session_state = state.session_state;\n    (_b = response.scope) != null ? _b : response.scope = state.scope;\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response, state.id_token);\n      logger2.debug(\"ID Token validated\");\n    }\n    if (!response.id_token) {\n      response.id_token = state.id_token;\n      response.profile = state.profile;\n    }\n    const hasIdToken = response.isOpenId && !!response.id_token;\n    await this._processClaims(response, false, hasIdToken);\n    logger2.debug(\"claims processed\");\n  }\n  validateSignoutResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSignoutResponse\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n  }\n  _processSigninState(response, state) {\n    var _a;\n    const logger2 = this._logger.create(\"_processSigninState\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    if (!state.client_id) {\n      logger2.throw(new Error(\"No client_id on state\"));\n    }\n    if (!state.authority) {\n      logger2.throw(new Error(\"No authority on state\"));\n    }\n    if (this._settings.authority !== state.authority) {\n      logger2.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n    }\n    if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n      logger2.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    (_a = response.scope) != null ? _a : response.scope = state.scope;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n    if (state.code_verifier && !response.code) {\n      logger2.throw(new Error(\"Expected code in response\"));\n    }\n    if (!state.code_verifier && response.code) {\n      logger2.throw(new Error(\"Unexpected code in response\"));\n    }\n  }\n  async _processClaims(response) {\n    let skipUserInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let validateSub = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const logger2 = this._logger.create(\"_processClaims\");\n    response.profile = this._filterProtocolClaims(response.profile);\n    if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n      logger2.debug(\"not loading user info\");\n      return;\n    }\n    logger2.debug(\"loading user info\");\n    const claims = await this._userInfoService.getClaims(response.access_token);\n    logger2.debug(\"user info claims received from user info endpoint\");\n    if (validateSub && claims.sub !== response.profile.sub) {\n      logger2.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n    }\n    response.profile = this._mergeClaims(response.profile, this._filterProtocolClaims(claims));\n    logger2.debug(\"user info claims received, updated profile:\", response.profile);\n  }\n  _mergeClaims(claims1, claims2) {\n    const result = {\n      ...claims1\n    };\n    for (const [claim, values] of Object.entries(claims2)) {\n      for (const value of Array.isArray(values) ? values : [values]) {\n        const previousValue = result[claim];\n        if (!previousValue) {\n          result[claim] = value;\n        } else if (Array.isArray(previousValue)) {\n          if (!previousValue.includes(value)) {\n            previousValue.push(value);\n          }\n        } else if (result[claim] !== value) {\n          if (typeof value === \"object\" && this._settings.mergeClaims) {\n            result[claim] = this._mergeClaims(previousValue, value);\n          } else {\n            result[claim] = [previousValue, value];\n          }\n        }\n      }\n    }\n    return result;\n  }\n  _filterProtocolClaims(claims) {\n    const result = {\n      ...claims\n    };\n    if (this._settings.filterProtocolClaims) {\n      for (const type of ProtocolClaims) {\n        delete result[type];\n      }\n    }\n    return result;\n  }\n  async _processCode(response, state) {\n    const logger2 = this._logger.create(\"_processCode\");\n    if (response.code) {\n      logger2.debug(\"Validating code\");\n      const tokenResponse = await this._tokenClient.exchangeCode({\n        client_id: state.client_id,\n        client_secret: state.client_secret,\n        code: response.code,\n        redirect_uri: state.redirect_uri,\n        code_verifier: state.code_verifier,\n        ...state.extraTokenParams\n      });\n      Object.assign(response, tokenResponse);\n    } else {\n      logger2.debug(\"No code to process\");\n    }\n  }\n  _validateIdTokenAttributes(response, currentToken) {\n    var _a;\n    const logger2 = this._logger.create(\"_validateIdTokenAttributes\");\n    logger2.debug(\"decoding ID Token JWT\");\n    const profile = JwtUtils.decode((_a = response.id_token) != null ? _a : \"\");\n    if (!profile.sub) {\n      logger2.throw(new Error(\"ID Token is missing a subject claim\"));\n    }\n    if (currentToken) {\n      const current = JwtUtils.decode(currentToken);\n      if (current.sub !== profile.sub) {\n        logger2.throw(new Error(\"sub in id_token does not match current sub\"));\n      }\n      if (current.auth_time && current.auth_time !== profile.auth_time) {\n        logger2.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n      }\n      if (current.azp && current.azp !== profile.azp) {\n        logger2.throw(new Error(\"azp in id_token does not match original azp\"));\n      }\n      if (!current.azp && profile.azp) {\n        logger2.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n      }\n    }\n    response.profile = profile;\n  }\n};\n\n// src/State.ts\nvar State = class {\n  constructor(args) {\n    this.id = args.id || CryptoUtils.generateUUIDv4();\n    this.data = args.data;\n    if (args.created && args.created > 0) {\n      this.created = args.created;\n    } else {\n      this.created = Timer.getEpochTime();\n    }\n    this.request_type = args.request_type;\n  }\n  toStorageString() {\n    new Logger(\"State\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"State\", \"fromStorageString\");\n    return new State(JSON.parse(storageString));\n  }\n  static async clearStaleState(storage, age) {\n    const logger2 = Logger.createStatic(\"State\", \"clearStaleState\");\n    const cutoff = Timer.getEpochTime() - age;\n    const keys = await storage.getAllKeys();\n    logger2.debug(\"got keys\", keys);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const item = await storage.get(key);\n      let remove = false;\n      if (item) {\n        try {\n          const state = State.fromStorageString(item);\n          logger2.debug(\"got item from key:\", key, state.created);\n          if (state.created <= cutoff) {\n            remove = true;\n          }\n        } catch (err) {\n          logger2.error(\"Error parsing state for key:\", key, err);\n          remove = true;\n        }\n      } else {\n        logger2.debug(\"no item in storage for key:\", key);\n        remove = true;\n      }\n      if (remove) {\n        logger2.debug(\"removed item for key:\", key);\n        void storage.remove(key);\n      }\n    }\n  }\n};\n\n// src/SigninState.ts\nvar SigninState = class extends State {\n  constructor(args) {\n    super(args);\n    if (args.code_verifier === true) {\n      this.code_verifier = CryptoUtils.generateCodeVerifier();\n    } else if (args.code_verifier) {\n      this.code_verifier = args.code_verifier;\n    }\n    if (this.code_verifier) {\n      this.code_challenge = CryptoUtils.generateCodeChallenge(this.code_verifier);\n    }\n    this.authority = args.authority;\n    this.client_id = args.client_id;\n    this.redirect_uri = args.redirect_uri;\n    this.scope = args.scope;\n    this.client_secret = args.client_secret;\n    this.extraTokenParams = args.extraTokenParams;\n    this.response_mode = args.response_mode;\n    this.skipUserInfo = args.skipUserInfo;\n  }\n  toStorageString() {\n    new Logger(\"SigninState\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      code_verifier: this.code_verifier,\n      authority: this.authority,\n      client_id: this.client_id,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope,\n      client_secret: this.client_secret,\n      extraTokenParams: this.extraTokenParams,\n      response_mode: this.response_mode,\n      skipUserInfo: this.skipUserInfo\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"SigninState\", \"fromStorageString\");\n    const data = JSON.parse(storageString);\n    return new SigninState(data);\n  }\n};\n\n// src/SigninRequest.ts\nvar SigninRequest = class {\n  constructor(_ref9) {\n    let {\n      url,\n      authority,\n      client_id,\n      redirect_uri,\n      response_type,\n      scope,\n      state_data,\n      response_mode,\n      request_type,\n      client_secret,\n      nonce,\n      skipUserInfo,\n      extraQueryParams,\n      extraTokenParams,\n      ...optionalParams\n    } = _ref9;\n    this._logger = new Logger(\"SigninRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    if (!client_id) {\n      this._logger.error(\"ctor: No client_id passed\");\n      throw new Error(\"client_id\");\n    }\n    if (!redirect_uri) {\n      this._logger.error(\"ctor: No redirect_uri passed\");\n      throw new Error(\"redirect_uri\");\n    }\n    if (!response_type) {\n      this._logger.error(\"ctor: No response_type passed\");\n      throw new Error(\"response_type\");\n    }\n    if (!scope) {\n      this._logger.error(\"ctor: No scope passed\");\n      throw new Error(\"scope\");\n    }\n    if (!authority) {\n      this._logger.error(\"ctor: No authority passed\");\n      throw new Error(\"authority\");\n    }\n    this.state = new SigninState({\n      data: state_data,\n      request_type,\n      code_verifier: true,\n      client_id,\n      authority,\n      redirect_uri,\n      response_mode,\n      client_secret,\n      scope,\n      extraTokenParams,\n      skipUserInfo\n    });\n    const parsedUrl = new URL(url);\n    parsedUrl.searchParams.append(\"client_id\", client_id);\n    parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n    parsedUrl.searchParams.append(\"response_type\", response_type);\n    parsedUrl.searchParams.append(\"scope\", scope);\n    if (nonce) {\n      parsedUrl.searchParams.append(\"nonce\", nonce);\n    }\n    parsedUrl.searchParams.append(\"state\", this.state.id);\n    if (this.state.code_challenge) {\n      parsedUrl.searchParams.append(\"code_challenge\", this.state.code_challenge);\n      parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n    }\n    for (const [key, value] of Object.entries({\n      response_mode,\n      ...optionalParams,\n      ...extraQueryParams\n    })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SigninResponse.ts\nvar OidcScope = \"openid\";\nvar SigninResponse = class {\n  constructor(params) {\n    this.access_token = \"\";\n    this.token_type = \"\";\n    this.profile = {};\n    this.state = params.get(\"state\");\n    this.session_state = params.get(\"session_state\");\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n    this.code = params.get(\"code\");\n  }\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (typeof value === \"string\") value = Number(value);\n    if (value !== void 0 && value >= 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  get isOpenId() {\n    var _a;\n    return ((_a = this.scope) == null ? void 0 : _a.split(\" \").includes(OidcScope)) || !!this.id_token;\n  }\n};\n\n// src/SignoutRequest.ts\nvar SignoutRequest = class {\n  constructor(_ref10) {\n    let {\n      url,\n      state_data,\n      id_token_hint,\n      post_logout_redirect_uri,\n      extraQueryParams,\n      request_type\n    } = _ref10;\n    this._logger = new Logger(\"SignoutRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    const parsedUrl = new URL(url);\n    if (id_token_hint) {\n      parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n    }\n    if (post_logout_redirect_uri) {\n      parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n      if (state_data) {\n        this.state = new State({\n          data: state_data,\n          request_type\n        });\n        parsedUrl.searchParams.append(\"state\", this.state.id);\n      }\n    }\n    for (const [key, value] of Object.entries({\n      ...extraQueryParams\n    })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SignoutResponse.ts\nvar SignoutResponse = class {\n  constructor(params) {\n    this.state = params.get(\"state\");\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n  }\n};\n\n// src/OidcClient.ts\nvar OidcClient = class {\n  constructor(settings) {\n    this._logger = new Logger(\"OidcClient\");\n    this.settings = new OidcClientSettingsStore(settings);\n    this.metadataService = new MetadataService(this.settings);\n    this._validator = new ResponseValidator(this.settings, this.metadataService);\n    this._tokenClient = new TokenClient(this.settings, this.metadataService);\n  }\n  async createSigninRequest(_ref11) {\n    let {\n      state,\n      request,\n      request_uri,\n      request_type,\n      id_token_hint,\n      login_hint,\n      skipUserInfo,\n      nonce,\n      response_type = this.settings.response_type,\n      scope = this.settings.scope,\n      redirect_uri = this.settings.redirect_uri,\n      prompt = this.settings.prompt,\n      display = this.settings.display,\n      max_age = this.settings.max_age,\n      ui_locales = this.settings.ui_locales,\n      acr_values = this.settings.acr_values,\n      resource = this.settings.resource,\n      response_mode = this.settings.response_mode,\n      extraQueryParams = this.settings.extraQueryParams,\n      extraTokenParams = this.settings.extraTokenParams\n    } = _ref11;\n    const logger2 = this._logger.create(\"createSigninRequest\");\n    if (response_type !== \"code\") {\n      throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n    }\n    const url = await this.metadataService.getAuthorizationEndpoint();\n    logger2.debug(\"Received authorization endpoint\", url);\n    const signinRequest = new SigninRequest({\n      url,\n      authority: this.settings.authority,\n      client_id: this.settings.client_id,\n      redirect_uri,\n      response_type,\n      scope,\n      state_data: state,\n      prompt,\n      display,\n      max_age,\n      ui_locales,\n      id_token_hint,\n      login_hint,\n      acr_values,\n      resource,\n      request,\n      request_uri,\n      extraQueryParams,\n      extraTokenParams,\n      request_type,\n      response_mode,\n      client_secret: this.settings.client_secret,\n      skipUserInfo,\n      nonce\n    });\n    await this.clearStaleState();\n    const signinState = signinRequest.state;\n    await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n    return signinRequest;\n  }\n  async readSigninResponseState(url) {\n    let removeState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const logger2 = this._logger.create(\"readSigninResponseState\");\n    const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.throw(new Error(\"No state in response\"));\n      throw null;\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = SigninState.fromStorageString(storedStateString);\n    return {\n      state,\n      response\n    };\n  }\n  async processSigninResponse(url) {\n    const logger2 = this._logger.create(\"processSigninResponse\");\n    const {\n      state,\n      response\n    } = await this.readSigninResponseState(url, true);\n    logger2.debug(\"received state from storage; validating response\");\n    await this._validator.validateSigninResponse(response, state);\n    return response;\n  }\n  async processResourceOwnerPasswordCredentials(_ref12) {\n    let {\n      username,\n      password,\n      skipUserInfo = false\n    } = _ref12;\n    const tokenResponse = await this._tokenClient.exchangeCredentials({\n      username,\n      password\n    });\n    const signinResponse = new SigninResponse(new URLSearchParams());\n    Object.assign(signinResponse, tokenResponse);\n    await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n    return signinResponse;\n  }\n  async useRefreshToken(_ref13) {\n    let {\n      state,\n      timeoutInSeconds\n    } = _ref13;\n    const logger2 = this._logger.create(\"useRefreshToken\");\n    const result = await this._tokenClient.exchangeRefreshToken({\n      refresh_token: state.refresh_token,\n      scope: state.scope,\n      timeoutInSeconds\n    });\n    const response = new SigninResponse(new URLSearchParams());\n    Object.assign(response, result);\n    logger2.debug(\"validating response\", response);\n    await this._validator.validateRefreshResponse(response, state);\n    return response;\n  }\n  async createSignoutRequest() {\n    let {\n      state,\n      id_token_hint,\n      request_type,\n      post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n      extraQueryParams = this.settings.extraQueryParams\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const logger2 = this._logger.create(\"createSignoutRequest\");\n    const url = await this.metadataService.getEndSessionEndpoint();\n    if (!url) {\n      logger2.throw(new Error(\"No end session endpoint\"));\n      throw null;\n    }\n    logger2.debug(\"Received end session endpoint\", url);\n    const request = new SignoutRequest({\n      url,\n      id_token_hint,\n      post_logout_redirect_uri,\n      state_data: state,\n      extraQueryParams,\n      request_type\n    });\n    await this.clearStaleState();\n    const signoutState = request.state;\n    if (signoutState) {\n      logger2.debug(\"Signout request has state to persist\");\n      await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n    }\n    return request;\n  }\n  async readSignoutResponseState(url) {\n    let removeState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const logger2 = this._logger.create(\"readSignoutResponseState\");\n    const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.debug(\"No state in response\");\n      if (response.error) {\n        logger2.warn(\"Response was error:\", response.error);\n        throw new ErrorResponse(response);\n      }\n      return {\n        state: void 0,\n        response\n      };\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = State.fromStorageString(storedStateString);\n    return {\n      state,\n      response\n    };\n  }\n  async processSignoutResponse(url) {\n    const logger2 = this._logger.create(\"processSignoutResponse\");\n    const {\n      state,\n      response\n    } = await this.readSignoutResponseState(url, true);\n    if (state) {\n      logger2.debug(\"Received state from storage; validating response\");\n      this._validator.validateSignoutResponse(response, state);\n    } else {\n      logger2.debug(\"No state from storage; skipping response validation\");\n    }\n    return response;\n  }\n  clearStaleState() {\n    this._logger.create(\"clearStaleState\");\n    return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n  }\n  async revokeToken(token, type) {\n    this._logger.create(\"revokeToken\");\n    return await this._tokenClient.revoke({\n      token,\n      token_type_hint: type\n    });\n  }\n};\n\n// src/SessionMonitor.ts\nvar SessionMonitor = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SessionMonitor\");\n    this._start = async user => {\n      const session_state = user.session_state;\n      if (!session_state) {\n        return;\n      }\n      const logger2 = this._logger.create(\"_start\");\n      if (user.profile) {\n        this._sub = user.profile.sub;\n        this._sid = user.profile.sid;\n        logger2.debug(\"session_state\", session_state, \", sub\", this._sub);\n      } else {\n        this._sub = void 0;\n        this._sid = void 0;\n        logger2.debug(\"session_state\", session_state, \", anonymous user\");\n      }\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.start(session_state);\n        return;\n      }\n      try {\n        const url = await this._userManager.metadataService.getCheckSessionIframe();\n        if (url) {\n          logger2.debug(\"initializing check session iframe\");\n          const client_id = this._userManager.settings.client_id;\n          const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n          const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n          const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n          await checkSessionIFrame.load();\n          this._checkSessionIFrame = checkSessionIFrame;\n          checkSessionIFrame.start(session_state);\n        } else {\n          logger2.warn(\"no check session iframe found in the metadata\");\n        }\n      } catch (err) {\n        logger2.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n      }\n    };\n    this._stop = () => {\n      const logger2 = this._logger.create(\"_stop\");\n      this._sub = void 0;\n      this._sid = void 0;\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.stop();\n      }\n      if (this._userManager.settings.monitorAnonymousSession) {\n        const timerHandle = setInterval(async () => {\n          clearInterval(timerHandle);\n          try {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n              const tmpUser = {\n                session_state: session.session_state,\n                profile: session.sub && session.sid ? {\n                  sub: session.sub,\n                  sid: session.sid\n                } : null\n              };\n              void this._start(tmpUser);\n            }\n          } catch (err) {\n            logger2.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n          }\n        }, 1e3);\n      }\n    };\n    this._callback = async () => {\n      const logger2 = this._logger.create(\"_callback\");\n      try {\n        const session = await this._userManager.querySessionStatus();\n        let raiseEvent = true;\n        if (session && this._checkSessionIFrame) {\n          if (session.sub === this._sub) {\n            raiseEvent = false;\n            this._checkSessionIFrame.start(session.session_state);\n            if (session.sid === this._sid) {\n              logger2.debug(\"same sub still logged in at OP, restarting check session iframe; session_state\", session.session_state);\n            } else {\n              logger2.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n              this._userManager.events._raiseUserSessionChanged();\n            }\n          } else {\n            logger2.debug(\"different subject signed into OP\", session.sub);\n          }\n        } else {\n          logger2.debug(\"subject no longer signed into OP\");\n        }\n        if (raiseEvent) {\n          if (this._sub) {\n            this._userManager.events._raiseUserSignedOut();\n          } else {\n            this._userManager.events._raiseUserSignedIn();\n          }\n        } else {\n          logger2.debug(\"no change in session detected, no event to raise\");\n        }\n      } catch (err) {\n        if (this._sub) {\n          logger2.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n          this._userManager.events._raiseUserSignedOut();\n        }\n      }\n    };\n    if (!_userManager) {\n      this._logger.throw(new Error(\"No user manager passed\"));\n    }\n    this._userManager.events.addUserLoaded(this._start);\n    this._userManager.events.addUserUnloaded(this._stop);\n    this._init().catch(err => {\n      this._logger.error(err);\n    });\n  }\n  async _init() {\n    this._logger.create(\"_init\");\n    const user = await this._userManager.getUser();\n    if (user) {\n      void this._start(user);\n    } else if (this._userManager.settings.monitorAnonymousSession) {\n      const session = await this._userManager.querySessionStatus();\n      if (session) {\n        const tmpUser = {\n          session_state: session.session_state,\n          profile: session.sub && session.sid ? {\n            sub: session.sub,\n            sid: session.sid\n          } : null\n        };\n        void this._start(tmpUser);\n      }\n    }\n  }\n};\n\n// src/User.ts\nvar User = class {\n  constructor(args) {\n    var _a;\n    this.id_token = args.id_token;\n    this.session_state = (_a = args.session_state) != null ? _a : null;\n    this.access_token = args.access_token;\n    this.refresh_token = args.refresh_token;\n    this.token_type = args.token_type;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.expires_at = args.expires_at;\n    this.state = args.userState;\n  }\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (value !== void 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  get expired() {\n    const expires_in = this.expires_in;\n    if (expires_in === void 0) {\n      return void 0;\n    }\n    return expires_in <= 0;\n  }\n  get scopes() {\n    var _a, _b;\n    return (_b = (_a = this.scope) == null ? void 0 : _a.split(\" \")) != null ? _b : [];\n  }\n  toStorageString() {\n    new Logger(\"User\").create(\"toStorageString\");\n    return JSON.stringify({\n      id_token: this.id_token,\n      session_state: this.session_state,\n      access_token: this.access_token,\n      refresh_token: this.refresh_token,\n      token_type: this.token_type,\n      scope: this.scope,\n      profile: this.profile,\n      expires_at: this.expires_at\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"User\", \"fromStorageString\");\n    return new User(JSON.parse(storageString));\n  }\n};\n\n// src/navigators/AbstractChildWindow.ts\nvar messageSource = \"oidc-client\";\nvar AbstractChildWindow = class {\n  constructor() {\n    this._abort = new Event(\"Window navigation aborted\");\n    this._disposeHandlers = /* @__PURE__ */new Set();\n    this._window = null;\n  }\n  async navigate(params) {\n    const logger2 = this._logger.create(\"navigate\");\n    if (!this._window) {\n      throw new Error(\"Attempted to navigate on a disposed window\");\n    }\n    logger2.debug(\"setting URL in window\");\n    this._window.location.replace(params.url);\n    const {\n      url,\n      keepOpen\n    } = await new Promise((resolve, reject) => {\n      const listener = e => {\n        var _a;\n        const data = e.data;\n        const origin = (_a = params.scriptOrigin) != null ? _a : window.location.origin;\n        if (e.origin !== origin || (data == null ? void 0 : data.source) !== messageSource) {\n          return;\n        }\n        try {\n          const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n          if (!state) {\n            logger2.warn(\"no state found in response url\");\n          }\n          if (e.source !== this._window && state !== params.state) {\n            return;\n          }\n        } catch (err) {\n          this._dispose();\n          reject(new Error(\"Invalid response from window\"));\n        }\n        resolve(data);\n      };\n      window.addEventListener(\"message\", listener, false);\n      this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n      this._disposeHandlers.add(this._abort.addHandler(reason => {\n        this._dispose();\n        reject(reason);\n      }));\n    });\n    logger2.debug(\"got response from window\");\n    this._dispose();\n    if (!keepOpen) {\n      this.close();\n    }\n    return {\n      url\n    };\n  }\n  _dispose() {\n    this._logger.create(\"_dispose\");\n    for (const dispose of this._disposeHandlers) {\n      dispose();\n    }\n    this._disposeHandlers.clear();\n  }\n  static _notifyParent(parent, url) {\n    let keepOpen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let targetOrigin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window.location.origin;\n    parent.postMessage({\n      source: messageSource,\n      url,\n      keepOpen\n    }, targetOrigin);\n  }\n};\n\n// src/UserManagerSettings.ts\nvar DefaultPopupWindowFeatures = {\n  location: false,\n  toolbar: false,\n  height: 640\n};\nvar DefaultPopupTarget = \"_blank\";\nvar DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nvar DefaultCheckSessionIntervalInSeconds = 2;\nvar DefaultSilentRequestTimeoutInSeconds = 10;\nvar UserManagerSettingsStore = class extends OidcClientSettingsStore {\n  constructor(args) {\n    const {\n      popup_redirect_uri = args.redirect_uri,\n      popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n      popupWindowFeatures = DefaultPopupWindowFeatures,\n      popupWindowTarget = DefaultPopupTarget,\n      redirectMethod = \"assign\",\n      redirectTarget = \"self\",\n      iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n      iframeScriptOrigin = args.iframeScriptOrigin,\n      silent_redirect_uri = args.redirect_uri,\n      silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n      automaticSilentRenew = true,\n      validateSubOnSilentRenew = true,\n      includeIdTokenInSilentRenew = false,\n      monitorSession = false,\n      monitorAnonymousSession = false,\n      checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n      query_status_response_type = \"code\",\n      stopCheckSessionOnError = true,\n      revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n      revokeTokensOnSignout = false,\n      includeIdTokenInSilentSignout = false,\n      accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n      userStore\n    } = args;\n    super(args);\n    this.popup_redirect_uri = popup_redirect_uri;\n    this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n    this.popupWindowFeatures = popupWindowFeatures;\n    this.popupWindowTarget = popupWindowTarget;\n    this.redirectMethod = redirectMethod;\n    this.redirectTarget = redirectTarget;\n    this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n    this.iframeScriptOrigin = iframeScriptOrigin;\n    this.silent_redirect_uri = silent_redirect_uri;\n    this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;\n    this.automaticSilentRenew = automaticSilentRenew;\n    this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n    this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n    this.monitorSession = monitorSession;\n    this.monitorAnonymousSession = monitorAnonymousSession;\n    this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n    this.stopCheckSessionOnError = stopCheckSessionOnError;\n    this.query_status_response_type = query_status_response_type;\n    this.revokeTokenTypes = revokeTokenTypes;\n    this.revokeTokensOnSignout = revokeTokensOnSignout;\n    this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n    this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n    if (userStore) {\n      this.userStore = userStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n      this.userStore = new WebStorageStateStore({\n        store\n      });\n    }\n  }\n};\n\n// src/navigators/IFrameWindow.ts\nvar IFrameWindow = class extends AbstractChildWindow {\n  constructor(_ref14) {\n    let {\n      silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds\n    } = _ref14;\n    super();\n    this._logger = new Logger(\"IFrameWindow\");\n    this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n    this._frame = IFrameWindow.createHiddenIframe();\n    this._window = this._frame.contentWindow;\n  }\n  static createHiddenIframe() {\n    const iframe = window.document.createElement(\"iframe\");\n    iframe.style.visibility = \"hidden\";\n    iframe.style.position = \"fixed\";\n    iframe.style.left = \"-1000px\";\n    iframe.style.top = \"0\";\n    iframe.width = \"0\";\n    iframe.height = \"0\";\n    iframe.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n    window.document.body.appendChild(iframe);\n    return iframe;\n  }\n  async navigate(params) {\n    this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n    const timer = setTimeout(() => this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1e3);\n    this._disposeHandlers.add(() => clearTimeout(timer));\n    return await super.navigate(params);\n  }\n  close() {\n    var _a;\n    if (this._frame) {\n      if (this._frame.parentNode) {\n        this._frame.addEventListener(\"load\", ev => {\n          var _a2;\n          const frame = ev.target;\n          (_a2 = frame.parentNode) == null ? void 0 : _a2.removeChild(frame);\n          this._abort.raise(new Error(\"IFrame removed from DOM\"));\n        }, true);\n        (_a = this._frame.contentWindow) == null ? void 0 : _a.location.replace(\"about:blank\");\n      }\n      this._frame = null;\n    }\n    this._window = null;\n  }\n  static notifyParent(url, targetOrigin) {\n    return super._notifyParent(window.parent, url, false, targetOrigin);\n  }\n};\n\n// src/navigators/IFrameNavigator.ts\nvar IFrameNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"IFrameNavigator\");\n  }\n  async prepare(_ref15) {\n    let {\n      silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds\n    } = _ref15;\n    return new IFrameWindow({\n      silentRequestTimeoutInSeconds\n    });\n  }\n  async callback(url) {\n    this._logger.create(\"callback\");\n    IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n  }\n};\n\n// src/navigators/PopupWindow.ts\nvar checkForPopupClosedInterval = 500;\nvar PopupWindow = class extends AbstractChildWindow {\n  constructor(_ref16) {\n    let {\n      popupWindowTarget = DefaultPopupTarget,\n      popupWindowFeatures = {}\n    } = _ref16;\n    super();\n    this._logger = new Logger(\"PopupWindow\");\n    const centeredPopup = PopupUtils.center({\n      ...DefaultPopupWindowFeatures,\n      ...popupWindowFeatures\n    });\n    this._window = window.open(void 0, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n  }\n  async navigate(params) {\n    var _a;\n    (_a = this._window) == null ? void 0 : _a.focus();\n    const popupClosedInterval = setInterval(() => {\n      if (!this._window || this._window.closed) {\n        this._abort.raise(new Error(\"Popup closed by user\"));\n      }\n    }, checkForPopupClosedInterval);\n    this._disposeHandlers.add(() => clearInterval(popupClosedInterval));\n    return await super.navigate(params);\n  }\n  close() {\n    if (this._window) {\n      if (!this._window.closed) {\n        this._window.close();\n        this._abort.raise(new Error(\"Popup closed\"));\n      }\n    }\n    this._window = null;\n  }\n  static notifyOpener(url, keepOpen) {\n    if (!window.opener) {\n      throw new Error(\"No window.opener. Can't complete notification.\");\n    }\n    return super._notifyParent(window.opener, url, keepOpen);\n  }\n};\n\n// src/navigators/PopupNavigator.ts\nvar PopupNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"PopupNavigator\");\n  }\n  async prepare(_ref17) {\n    let {\n      popupWindowFeatures = this._settings.popupWindowFeatures,\n      popupWindowTarget = this._settings.popupWindowTarget\n    } = _ref17;\n    return new PopupWindow({\n      popupWindowFeatures,\n      popupWindowTarget\n    });\n  }\n  async callback(url) {\n    let keepOpen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this._logger.create(\"callback\");\n    PopupWindow.notifyOpener(url, keepOpen);\n  }\n};\n\n// src/navigators/RedirectNavigator.ts\nvar RedirectNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"RedirectNavigator\");\n  }\n  async prepare(_ref18) {\n    let {\n      redirectMethod = this._settings.redirectMethod,\n      redirectTarget = this._settings.redirectTarget\n    } = _ref18;\n    var _a;\n    this._logger.create(\"prepare\");\n    let targetWindow = window.self;\n    if (redirectTarget === \"top\") {\n      targetWindow = (_a = window.top) != null ? _a : window.self;\n    }\n    const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);\n    let abort;\n    return {\n      navigate: async params => {\n        this._logger.create(\"navigate\");\n        const promise = new Promise((resolve, reject) => {\n          abort = reject;\n        });\n        redirect(params.url);\n        return await promise;\n      },\n      close: () => {\n        this._logger.create(\"close\");\n        abort == null ? void 0 : abort(new Error(\"Redirect aborted\"));\n        targetWindow.stop();\n      }\n    };\n  }\n};\n\n// src/UserManagerEvents.ts\nvar UserManagerEvents = class extends AccessTokenEvents {\n  constructor(settings) {\n    super({\n      expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds\n    });\n    this._logger = new Logger(\"UserManagerEvents\");\n    this._userLoaded = new Event(\"User loaded\");\n    this._userUnloaded = new Event(\"User unloaded\");\n    this._silentRenewError = new Event(\"Silent renew error\");\n    this._userSignedIn = new Event(\"User signed in\");\n    this._userSignedOut = new Event(\"User signed out\");\n    this._userSessionChanged = new Event(\"User session changed\");\n  }\n  load(user) {\n    let raiseEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    super.load(user);\n    if (raiseEvent) {\n      this._userLoaded.raise(user);\n    }\n  }\n  unload() {\n    super.unload();\n    this._userUnloaded.raise();\n  }\n  addUserLoaded(cb) {\n    return this._userLoaded.addHandler(cb);\n  }\n  removeUserLoaded(cb) {\n    return this._userLoaded.removeHandler(cb);\n  }\n  addUserUnloaded(cb) {\n    return this._userUnloaded.addHandler(cb);\n  }\n  removeUserUnloaded(cb) {\n    return this._userUnloaded.removeHandler(cb);\n  }\n  addSilentRenewError(cb) {\n    return this._silentRenewError.addHandler(cb);\n  }\n  removeSilentRenewError(cb) {\n    return this._silentRenewError.removeHandler(cb);\n  }\n  _raiseSilentRenewError(e) {\n    this._silentRenewError.raise(e);\n  }\n  addUserSignedIn(cb) {\n    return this._userSignedIn.addHandler(cb);\n  }\n  removeUserSignedIn(cb) {\n    this._userSignedIn.removeHandler(cb);\n  }\n  _raiseUserSignedIn() {\n    this._userSignedIn.raise();\n  }\n  addUserSignedOut(cb) {\n    return this._userSignedOut.addHandler(cb);\n  }\n  removeUserSignedOut(cb) {\n    this._userSignedOut.removeHandler(cb);\n  }\n  _raiseUserSignedOut() {\n    this._userSignedOut.raise();\n  }\n  addUserSessionChanged(cb) {\n    return this._userSessionChanged.addHandler(cb);\n  }\n  removeUserSessionChanged(cb) {\n    this._userSessionChanged.removeHandler(cb);\n  }\n  _raiseUserSessionChanged() {\n    this._userSessionChanged.raise();\n  }\n};\n\n// src/SilentRenewService.ts\nvar SilentRenewService = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SilentRenewService\");\n    this._isStarted = false;\n    this._retryTimer = new Timer(\"Retry Silent Renew\");\n    this._tokenExpiring = async () => {\n      const logger2 = this._logger.create(\"_tokenExpiring\");\n      try {\n        await this._userManager.signinSilent();\n        logger2.debug(\"silent token renewal successful\");\n      } catch (err) {\n        if (err instanceof ErrorTimeout) {\n          logger2.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n          this._retryTimer.init(5);\n          return;\n        }\n        logger2.error(\"Error from signinSilent:\", err);\n        this._userManager.events._raiseSilentRenewError(err);\n      }\n    };\n  }\n  async start() {\n    const logger2 = this._logger.create(\"start\");\n    if (!this._isStarted) {\n      this._isStarted = true;\n      this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n      this._retryTimer.addHandler(this._tokenExpiring);\n      try {\n        await this._userManager.getUser();\n      } catch (err) {\n        logger2.error(\"getUser error\", err);\n      }\n    }\n  }\n  stop() {\n    if (this._isStarted) {\n      this._retryTimer.cancel();\n      this._retryTimer.removeHandler(this._tokenExpiring);\n      this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n      this._isStarted = false;\n    }\n  }\n};\n\n// src/RefreshState.ts\nvar RefreshState = class {\n  constructor(args) {\n    this.refresh_token = args.refresh_token;\n    this.id_token = args.id_token;\n    this.session_state = args.session_state;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.data = args.state;\n  }\n};\n\n// src/UserManager.ts\nvar UserManager = class {\n  constructor(settings) {\n    this._logger = new Logger(\"UserManager\");\n    this.settings = new UserManagerSettingsStore(settings);\n    this._client = new OidcClient(settings);\n    this._redirectNavigator = new RedirectNavigator(this.settings);\n    this._popupNavigator = new PopupNavigator(this.settings);\n    this._iframeNavigator = new IFrameNavigator(this.settings);\n    this._events = new UserManagerEvents(this.settings);\n    this._silentRenewService = new SilentRenewService(this);\n    if (this.settings.automaticSilentRenew) {\n      this.startSilentRenew();\n    }\n    this._sessionMonitor = null;\n    if (this.settings.monitorSession) {\n      this._sessionMonitor = new SessionMonitor(this);\n    }\n  }\n  get events() {\n    return this._events;\n  }\n  get metadataService() {\n    return this._client.metadataService;\n  }\n  async getUser() {\n    const logger2 = this._logger.create(\"getUser\");\n    const user = await this._loadUser();\n    if (user) {\n      logger2.info(\"user loaded\");\n      this._events.load(user, false);\n      return user;\n    }\n    logger2.info(\"user not found in storage\");\n    return null;\n  }\n  async removeUser() {\n    const logger2 = this._logger.create(\"removeUser\");\n    await this.storeUser(null);\n    logger2.info(\"user removed from storage\");\n    this._events.unload();\n  }\n  async signinRedirect() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._logger.create(\"signinRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({\n      redirectMethod\n    });\n    await this._signinStart({\n      request_type: \"si:r\",\n      ...requestArgs\n    }, handle);\n  }\n  async signinRedirectCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    const logger2 = this._logger.create(\"signinRedirectCallback\");\n    const user = await this._signinEnd(url);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  async signinResourceOwnerCredentials(_ref19) {\n    let {\n      username,\n      password,\n      skipUserInfo = false\n    } = _ref19;\n    const logger2 = this._logger.create(\"signinResourceOwnerCredential\");\n    const signinResponse = await this._client.processResourceOwnerPasswordCredentials({\n      username,\n      password,\n      skipUserInfo\n    });\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  async signinPopup() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const logger2 = this._logger.create(\"signinPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No popup_redirect_uri configured\"));\n    }\n    const handle = await this._popupNavigator.prepare({\n      popupWindowFeatures,\n      popupWindowTarget\n    });\n    const user = await this._signin({\n      request_type: \"si:p\",\n      redirect_uri: url,\n      display: \"popup\",\n      ...requestArgs\n    }, handle);\n    if (user) {\n      if (user.profile && user.profile.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  async signinPopupCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    let keepOpen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const logger2 = this._logger.create(\"signinPopupCallback\");\n    await this._popupNavigator.callback(url, keepOpen);\n    logger2.info(\"success\");\n  }\n  async signinSilent() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _a;\n    const logger2 = this._logger.create(\"signinSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    let user = await this._loadUser();\n    if (user == null ? void 0 : user.refresh_token) {\n      logger2.debug(\"using refresh token\");\n      const state = new RefreshState(user);\n      return await this._useRefreshToken(state);\n    }\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    let verifySub;\n    if (user && this.settings.validateSubOnSilentRenew) {\n      logger2.debug(\"subject prior to silent renew:\", user.profile.sub);\n      verifySub = user.profile.sub;\n    }\n    const handle = await this._iframeNavigator.prepare({\n      silentRequestTimeoutInSeconds\n    });\n    user = await this._signin({\n      request_type: \"si:s\",\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      ...requestArgs\n    }, handle, verifySub);\n    if (user) {\n      if ((_a = user.profile) == null ? void 0 : _a.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  async _useRefreshToken(state) {\n    const response = await this._client.useRefreshToken({\n      state,\n      timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds\n    });\n    const user = new User({\n      ...state,\n      ...response\n    });\n    await this.storeUser(user);\n    this._events.load(user);\n    return user;\n  }\n  async signinSilentCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    const logger2 = this._logger.create(\"signinSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async signinCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    const {\n      state\n    } = await this._client.readSigninResponseState(url);\n    switch (state.request_type) {\n      case \"si:r\":\n        return await this.signinRedirectCallback(url);\n      case \"si:p\":\n        return await this.signinPopupCallback(url);\n      case \"si:s\":\n        return await this.signinSilentCallback(url);\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n  }\n  async signoutCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    let keepOpen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      state\n    } = await this._client.readSignoutResponseState(url);\n    if (!state) {\n      return;\n    }\n    switch (state.request_type) {\n      case \"so:r\":\n        await this.signoutRedirectCallback(url);\n        break;\n      case \"so:p\":\n        await this.signoutPopupCallback(url, keepOpen);\n        break;\n      case \"so:s\":\n        await this.signoutSilentCallback(url);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n  }\n  async querySessionStatus() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const logger2 = this._logger.create(\"querySessionStatus\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    const user = await this._loadUser();\n    const handle = await this._iframeNavigator.prepare({\n      silentRequestTimeoutInSeconds\n    });\n    const navResponse = await this._signinStart({\n      request_type: \"si:s\",\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      response_type: this.settings.query_status_response_type,\n      scope: \"openid\",\n      skipUserInfo: true,\n      ...requestArgs\n    }, handle);\n    try {\n      const signinResponse = await this._client.processSigninResponse(navResponse.url);\n      logger2.debug(\"got signin response\");\n      if (signinResponse.session_state && signinResponse.profile.sub) {\n        logger2.info(\"success for subject\", signinResponse.profile.sub);\n        return {\n          session_state: signinResponse.session_state,\n          sub: signinResponse.profile.sub,\n          sid: signinResponse.profile.sid\n        };\n      }\n      logger2.info(\"success, user not authenticated\");\n      return null;\n    } catch (err) {\n      if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n        switch (err.error) {\n          case \"login_required\":\n          case \"consent_required\":\n          case \"interaction_required\":\n          case \"account_selection_required\":\n            logger2.info(\"success for anonymous user\");\n            return {\n              session_state: err.session_state\n            };\n        }\n      }\n      throw err;\n    }\n  }\n  async _signin(args, handle, verifySub) {\n    const navResponse = await this._signinStart(args, handle);\n    return await this._signinEnd(navResponse.url, verifySub);\n  }\n  async _signinStart(args, handle) {\n    const logger2 = this._logger.create(\"_signinStart\");\n    try {\n      const signinRequest = await this._client.createSigninRequest(args);\n      logger2.debug(\"got signin request\");\n      return await handle.navigate({\n        url: signinRequest.url,\n        state: signinRequest.state.id,\n        response_mode: signinRequest.state.response_mode,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signinEnd(url, verifySub) {\n    const logger2 = this._logger.create(\"_signinEnd\");\n    const signinResponse = await this._client.processSigninResponse(url);\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse, verifySub);\n    return user;\n  }\n  async _buildUser(signinResponse, verifySub) {\n    const logger2 = this._logger.create(\"_buildUser\");\n    const user = new User(signinResponse);\n    if (verifySub) {\n      if (verifySub !== user.profile.sub) {\n        logger2.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n        throw new ErrorResponse({\n          ...signinResponse,\n          error: \"login_required\"\n        });\n      }\n      logger2.debug(\"current user matches user returned from signin\");\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    this._events.load(user);\n    return user;\n  }\n  async signoutRedirect() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const logger2 = this._logger.create(\"signoutRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({\n      redirectMethod\n    });\n    await this._signoutStart({\n      request_type: \"so:r\",\n      post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  async signoutRedirectCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    const logger2 = this._logger.create(\"signoutRedirectCallback\");\n    const response = await this._signoutEnd(url);\n    logger2.info(\"success\");\n    return response;\n  }\n  async signoutPopup() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const logger2 = this._logger.create(\"signoutPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._popupNavigator.prepare({\n      popupWindowFeatures,\n      popupWindowTarget\n    });\n    await this._signout({\n      request_type: \"so:p\",\n      post_logout_redirect_uri: url,\n      state: url == null ? void 0 : {},\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  async signoutPopupCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    let keepOpen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const logger2 = this._logger.create(\"signoutPopupCallback\");\n    await this._popupNavigator.callback(url, keepOpen);\n    logger2.info(\"success\");\n  }\n  async _signout(args, handle) {\n    const navResponse = await this._signoutStart(args, handle);\n    return await this._signoutEnd(navResponse.url);\n  }\n  async _signoutStart() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let handle = arguments.length > 1 ? arguments[1] : undefined;\n    var _a;\n    const logger2 = this._logger.create(\"_signoutStart\");\n    try {\n      const user = await this._loadUser();\n      logger2.debug(\"loaded current user from storage\");\n      if (this.settings.revokeTokensOnSignout) {\n        await this._revokeInternal(user);\n      }\n      const id_token = args.id_token_hint || user && user.id_token;\n      if (id_token) {\n        logger2.debug(\"setting id_token_hint in signout request\");\n        args.id_token_hint = id_token;\n      }\n      await this.removeUser();\n      logger2.debug(\"user removed, creating signout request\");\n      const signoutRequest = await this._client.createSignoutRequest(args);\n      logger2.debug(\"got signout request\");\n      return await handle.navigate({\n        url: signoutRequest.url,\n        state: (_a = signoutRequest.state) == null ? void 0 : _a.id\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signoutEnd(url) {\n    const logger2 = this._logger.create(\"_signoutEnd\");\n    const signoutResponse = await this._client.processSignoutResponse(url);\n    logger2.debug(\"got signout response\");\n    return signoutResponse;\n  }\n  async signoutSilent() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _a;\n    const logger2 = this._logger.create(\"signoutSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a = await this._loadUser()) == null ? void 0 : _a.id_token : void 0;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._iframeNavigator.prepare({\n      silentRequestTimeoutInSeconds\n    });\n    await this._signout({\n      request_type: \"so:s\",\n      post_logout_redirect_uri: url,\n      id_token_hint,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  async signoutSilentCallback() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;\n    const logger2 = this._logger.create(\"signoutSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async revokeTokens(types) {\n    const user = await this._loadUser();\n    await this._revokeInternal(user, types);\n  }\n  async _revokeInternal(user) {\n    let types = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.settings.revokeTokenTypes;\n    const logger2 = this._logger.create(\"_revokeInternal\");\n    if (!user) return;\n    const typesPresent = types.filter(type => typeof user[type] === \"string\");\n    if (!typesPresent.length) {\n      logger2.debug(\"no need to revoke due to no token(s)\");\n      return;\n    }\n    for (const type of typesPresent) {\n      await this._client.revokeToken(user[type], type);\n      logger2.info(`${type} revoked successfully`);\n      if (type !== \"access_token\") {\n        user[type] = null;\n      }\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    this._events.load(user);\n  }\n  startSilentRenew() {\n    this._logger.create(\"startSilentRenew\");\n    void this._silentRenewService.start();\n  }\n  stopSilentRenew() {\n    this._silentRenewService.stop();\n  }\n  get _userStoreKey() {\n    return `user:${this.settings.authority}:${this.settings.client_id}`;\n  }\n  async _loadUser() {\n    const logger2 = this._logger.create(\"_loadUser\");\n    const storageString = await this.settings.userStore.get(this._userStoreKey);\n    if (storageString) {\n      logger2.debug(\"user storageString loaded\");\n      return User.fromStorageString(storageString);\n    }\n    logger2.debug(\"no user storageString\");\n    return null;\n  }\n  async storeUser(user) {\n    const logger2 = this._logger.create(\"storeUser\");\n    if (user) {\n      logger2.debug(\"storing user\");\n      const storageString = user.toStorageString();\n      await this.settings.userStore.set(this._userStoreKey, storageString);\n    } else {\n      this._logger.debug(\"removing user\");\n      await this.settings.userStore.remove(this._userStoreKey);\n    }\n  }\n  async clearStaleState() {\n    await this._client.clearStaleState();\n  }\n};\n\n// package.json\nvar version = \"2.2.0\";\n\n// src/Version.ts\nvar Version = version;\nexport { AccessTokenEvents, CheckSessionIFrame, ErrorResponse, ErrorTimeout, InMemoryWebStorage, Log, Logger, MetadataService, OidcClient, OidcClientSettingsStore, SessionMonitor, SigninResponse, SigninState, SignoutResponse, State, User, UserManager, UserManagerSettingsStore, Version, WebStorageStateStore };","map":{"version":3,"mappings":"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","names":["CryptoJS","sha256","Base64","Utf8","nopLogger","debug","info","warn","error","level","logger","Log","reset","setLevel","value","Error","setLogger","Logger","constructor","_name","args","_format","_method","throw","err","create","method","methodLogger","Object","createStatic","name","staticMethod","staticLogger","prefix","UUID_V4_TEMPLATE","CryptoUtils","_randomWord","lib","WordArray","random","words","generateUUIDv4","uuid","replace","c","toString","generateCodeVerifier","generateCodeChallenge","code_verifier","hashed","stringify","generateBasicAuth","client_id","client_secret","basicAuth","parse","join","Event","_logger","_callbacks","addHandler","cb","push","removeHandler","idx","lastIndexOf","splice","raise","ev","jwt_decode","JwtUtils","decode","token","PopupUtils","center","features","width","_a","find","window","outerWidth","left","Math","max","round","screenX","height","top","screenY","outerHeight","serialize","entries","filter","map","key","Timer","_timerHandle","_expiration","_callback","diff","getEpochTime","cancel","floor","Date","now","init","durationInSeconds","expiration","timerDurationInSeconds","min","setInterval","clearInterval","UrlUtils","readParams","url","responseMode","TypeError","parsedUrl","URL","location","origin","params","URLSearchParams","slice","ErrorResponse","form","error_description","error_uri","_b","state","userState","session_state","_c","ErrorTimeout","message","AccessTokenEvents","_expiringTimer","_expiredTimer","_expiringNotificationTimeInSeconds","expiringNotificationTimeInSeconds","load","container","access_token","expires_in","duration","expiring","expired","unload","addAccessTokenExpiring","removeAccessTokenExpiring","addAccessTokenExpired","removeAccessTokenExpired","CheckSessionIFrame","_client_id","_intervalInSeconds","_stopOnError","_timer","_session_state","_message","e","_frame_origin","source","_frame","contentWindow","data","stop","document","createElement","style","visibility","position","src","href","Promise","resolve","onload","body","appendChild","addEventListener","start","send","postMessage","InMemoryWebStorage","_data","clear","getItem","setItem","removeItem","length","getOwnPropertyNames","index","JsonService","additionalContentTypes","_jwtHandler","_contentTypes","fetchWithTimeout","input","timeoutInSeconds","initFetch","fetch","controller","AbortController","timeoutId","setTimeout","abort","response","signal","DOMException","clearTimeout","getJson","credentials","headers","status","contentType","get","item","startsWith","ok","text","json","statusText","JSON","postForm","initCredentials","responseText","MetadataService","_settings","_jsonService","_signingKeys","_metadata","_metadataUrl","metadataUrl","signingKeys","metadata","fetchRequestCredentials","_fetchRequestCredentials","resetSigningKeys","getMetadata","assign","metadataSeed","getIssuer","_getMetadataProperty","getAuthorizationEndpoint","getUserInfoEndpoint","getTokenEndpoint","optional","getCheckSessionIframe","getEndSessionEndpoint","getRevocationEndpoint","getKeysEndpoint","getSigningKeys","jwks_uri","keySet","Array","isArray","keys","WebStorageStateStore","store","localStorage","_store","_prefix","set","remove","getAllKeys","len","indexOf","substr","DefaultResponseType","DefaultScope","DefaultClientAuthentication","DefaultResponseMode","DefaultStaleStateAgeInSeconds","DefaultClockSkewInSeconds","OidcClientSettingsStore","authority","response_type","scope","redirect_uri","post_logout_redirect_uri","client_authentication","prompt","display","max_age","ui_locales","acr_values","resource","response_mode","filterProtocolClaims","loadUserInfo","staleStateAgeInSeconds","clockSkewInSeconds","userInfoJwtIssuer","mergeClaims","stateStore","refreshTokenCredentials","revokeTokenAdditionalContentTypes","extraQueryParams","extraTokenParams","endsWith","console","UserInfoService","_metadataService","_getClaimsFromJwt","payload","getClaims","claims","TokenClient","exchangeCode","grant_type","code","append","exchangeCredentials","username","password","exchangeRefreshToken","refresh_token","revoke","token_type_hint","ProtocolClaims","ResponseValidator","_userInfoService","_tokenClient","validateSigninResponse","_processSigninState","_processCode","isOpenId","_validateIdTokenAttributes","_processClaims","skipUserInfo","validateCredentialsResponse","validateRefreshResponse","id_token","profile","hasIdToken","validateSignoutResponse","id","validateSub","_filterProtocolClaims","sub","_mergeClaims","claims1","claims2","result","claim","values","previousValue","includes","type","tokenResponse","currentToken","current","auth_time","azp","State","created","request_type","toStorageString","fromStorageString","storageString","clearStaleState","storage","age","cutoff","i","SigninState","code_challenge","SigninRequest","state_data","nonce","optionalParams","searchParams","OidcScope","SigninResponse","token_type","expires_at","Number","split","SignoutRequest","id_token_hint","SignoutResponse","OidcClient","settings","metadataService","_validator","createSigninRequest","request","request_uri","login_hint","signinRequest","signinState","readSigninResponseState","removeState","storedStateString","processSigninResponse","processResourceOwnerPasswordCredentials","signinResponse","useRefreshToken","createSignoutRequest","signoutState","readSignoutResponseState","processSignoutResponse","revokeToken","SessionMonitor","_userManager","_start","user","_sub","_sid","sid","_checkSessionIFrame","intervalInSeconds","checkSessionIntervalInSeconds","stopOnError","stopCheckSessionOnError","checkSessionIFrame","_stop","monitorAnonymousSession","timerHandle","session","querySessionStatus","tmpUser","raiseEvent","events","_raiseUserSessionChanged","_raiseUserSignedOut","_raiseUserSignedIn","addUserLoaded","addUserUnloaded","_init","catch","getUser","User","scopes","messageSource","AbstractChildWindow","_abort","_disposeHandlers","Set","_window","navigate","keepOpen","reject","listener","scriptOrigin","_dispose","add","removeEventListener","reason","close","dispose","_notifyParent","parent","targetOrigin","DefaultPopupWindowFeatures","toolbar","DefaultPopupTarget","DefaultAccessTokenExpiringNotificationTimeInSeconds","DefaultCheckSessionIntervalInSeconds","DefaultSilentRequestTimeoutInSeconds","UserManagerSettingsStore","popup_redirect_uri","popup_post_logout_redirect_uri","popupWindowFeatures","popupWindowTarget","redirectMethod","redirectTarget","iframeNotifyParentOrigin","iframeScriptOrigin","silent_redirect_uri","silentRequestTimeoutInSeconds","automaticSilentRenew","validateSubOnSilentRenew","includeIdTokenInSilentRenew","monitorSession","query_status_response_type","revokeTokenTypes","revokeTokensOnSignout","includeIdTokenInSilentSignout","accessTokenExpiringNotificationTimeInSeconds","userStore","sessionStorage","IFrameWindow","_timeoutInSeconds","createHiddenIframe","iframe","setAttribute","timer","parentNode","frame","target","removeChild","notifyParent","IFrameNavigator","prepare","callback","checkForPopupClosedInterval","PopupWindow","centeredPopup","open","focus","popupClosedInterval","closed","notifyOpener","opener","PopupNavigator","RedirectNavigator","targetWindow","self","redirect","bind","promise","UserManagerEvents","_userLoaded","_userUnloaded","_silentRenewError","_userSignedIn","_userSignedOut","_userSessionChanged","removeUserLoaded","removeUserUnloaded","addSilentRenewError","removeSilentRenewError","_raiseSilentRenewError","addUserSignedIn","removeUserSignedIn","addUserSignedOut","removeUserSignedOut","addUserSessionChanged","removeUserSessionChanged","SilentRenewService","_isStarted","_retryTimer","_tokenExpiring","signinSilent","RefreshState","UserManager","_client","_redirectNavigator","_popupNavigator","_iframeNavigator","_events","_silentRenewService","startSilentRenew","_sessionMonitor","_loadUser","removeUser","storeUser","signinRedirect","requestArgs","handle","_signinStart","signinRedirectCallback","_signinEnd","signinResourceOwnerCredentials","_buildUser","signinPopup","_signin","signinPopupCallback","_useRefreshToken","verifySub","signinSilentCallback","signinCallback","signoutCallback","signoutRedirectCallback","signoutPopupCallback","signoutSilentCallback","navResponse","signoutRedirect","_signoutStart","_signoutEnd","signoutPopup","_signout","_revokeInternal","signoutRequest","signoutResponse","signoutSilent","revokeTokens","types","typesPresent","stopSilentRenew","_userStoreKey","Version","version"],"sources":["C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\utils\\CryptoUtils.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\utils\\Logger.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\utils\\Event.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\utils\\JwtUtils.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\utils\\PopupUtils.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\utils\\Timer.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\utils\\UrlUtils.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\errors\\ErrorResponse.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\errors\\ErrorTimeout.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\AccessTokenEvents.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\CheckSessionIFrame.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\InMemoryWebStorage.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\JsonService.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\MetadataService.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\WebStorageStateStore.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\OidcClientSettings.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\UserInfoService.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\TokenClient.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\ResponseValidator.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\State.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\SigninState.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\SigninRequest.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\SigninResponse.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\SignoutRequest.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\SignoutResponse.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\OidcClient.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\SessionMonitor.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\User.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\navigators\\AbstractChildWindow.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\UserManagerSettings.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\navigators\\IFrameWindow.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\navigators\\IFrameNavigator.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\navigators\\PopupWindow.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\navigators\\PopupNavigator.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\navigators\\RedirectNavigator.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\UserManagerEvents.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\SilentRenewService.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\RefreshState.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\UserManager.ts","C:\\Users\\Amanpreet\\github\\main\\react-user-authentication-main\\node_modules\\oidc-client-ts\\src\\Version.ts"],"sourcesContent":["import CryptoJS from \"crypto-js/core.js\";\nimport sha256 from \"crypto-js/sha256.js\";\nimport Base64 from \"crypto-js/enc-base64.js\";\nimport Utf8 from \"crypto-js/enc-utf8.js\";\n\nimport { Logger } from \"./Logger\";\n\nconst UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\n\n/**\n * @internal\n */\nexport class CryptoUtils {\n    private static _randomWord(): number {\n        return CryptoJS.lib.WordArray.random(1).words[0];\n    }\n\n    /**\n     * Generates RFC4122 version 4 guid\n     */\n    public static generateUUIDv4(): string {\n        const uuid = UUID_V4_TEMPLATE.replace(/[018]/g, c =>\n            (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16),\n        );\n        return uuid.replace(/-/g, \"\");\n    }\n\n    /**\n     * PKCE: Generate a code verifier\n     */\n    public static generateCodeVerifier(): string {\n        return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n    }\n\n    /**\n     * PKCE: Generate a code challenge\n     */\n    public static generateCodeChallenge(code_verifier: string): string {\n        try {\n            const hashed = sha256(code_verifier);\n            return Base64.stringify(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n        }\n        catch (err) {\n            Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n            throw err;\n        }\n    }\n\n    /**\n     * Generates a base64-encoded string for a basic auth header\n     */\n    public static generateBasicAuth(client_id: string, client_secret: string): string {\n        const basicAuth = Utf8.parse([client_id, client_secret].join(\":\"));\n        return Base64.stringify(basicAuth);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Native interface\n *\n * @public\n */\nexport interface ILogger {\n    debug(...args: unknown[]): void;\n    info(...args: unknown[]): void;\n    warn(...args: unknown[]): void;\n    error(...args: unknown[]): void;\n}\n\nconst nopLogger: ILogger = {\n    debug: () => undefined,\n    info: () => undefined,\n    warn: () => undefined,\n    error: () => undefined,\n};\n\nlet level: number;\nlet logger: ILogger;\n\n/**\n * Log levels\n *\n * @public\n */\nexport enum Log {\n    NONE,\n    ERROR,\n    WARN,\n    INFO,\n    DEBUG\n}\n\n/**\n * Log manager\n *\n * @public\n */\nexport namespace Log { // eslint-disable-line @typescript-eslint/no-namespace\n    export function reset(): void {\n        level = Log.INFO;\n        logger = nopLogger;\n    }\n\n    export function setLevel(value: Log): void {\n        if (!(Log.NONE <= value && value <= Log.DEBUG)) {\n            throw new Error(\"Invalid log level\");\n        }\n        level = value;\n    }\n\n    export function setLogger(value: ILogger): void {\n        logger = value;\n    }\n}\n\n/**\n * Internal logger instance\n *\n * @public\n */\nexport class Logger {\n    private _method?: string;\n    public constructor(private _name: string) {}\n\n    public debug(...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public info(...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public warn(...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public error(...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(this._name, this._method), ...args);\n        }\n    }\n\n    public throw(err: Error): never {\n        this.error(err);\n        throw err;\n    }\n\n    public create(method: string): Logger {\n        const methodLogger: Logger = Object.create(this);\n        methodLogger._method = method;\n        methodLogger.debug(\"begin\");\n        return methodLogger;\n    }\n\n    public static createStatic(name: string, staticMethod: string): Logger {\n        const staticLogger = new Logger(`${name}.${staticMethod}`);\n        staticLogger.debug(\"begin\");\n        return staticLogger;\n    }\n\n    private static _format(name: string, method?: string) {\n        const prefix = `[${name}]`;\n        return method ? `${prefix} ${method}:` : prefix;\n    }\n\n    // helpers for static class methods\n    public static debug(name: string, ...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(name), ...args);\n        }\n    }\n    public static info(name: string, ...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(name), ...args);\n        }\n    }\n    public static warn(name: string, ...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(name), ...args);\n        }\n    }\n    public static error(name: string, ...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(name), ...args);\n        }\n    }\n}\n\nLog.reset();\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport type Callback<EventType extends unknown[]> = (...ev: EventType) => (Promise<void> | void);\n\n/**\n * @internal\n */\nexport class Event<EventType extends unknown[]> {\n    protected readonly _logger = new Logger(`Event('${this._name}')`);\n\n    private _callbacks: Array<Callback<EventType>> = [];\n\n    public constructor(protected readonly _name: string) {}\n\n    public addHandler(cb: Callback<EventType>): () => void {\n        this._callbacks.push(cb);\n        return () => this.removeHandler(cb);\n    }\n\n    public removeHandler(cb: Callback<EventType>): void {\n        const idx = this._callbacks.lastIndexOf(cb);\n        if (idx >= 0) {\n            this._callbacks.splice(idx, 1);\n        }\n    }\n\n    public raise(...ev: EventType): void {\n        this._logger.debug(\"raise:\", ...ev);\n        for (const cb of this._callbacks) {\n            void cb(...ev);\n        }\n    }\n}\n","import jwt_decode from \"jwt-decode\";\n\nimport { Logger } from \"./Logger\";\nimport type { JwtClaims } from \"../Claims\";\n\n/**\n * @internal\n */\nexport class JwtUtils {\n    // IMPORTANT: doesn't validate the token\n    public static decode(token: string): JwtClaims {\n        try {\n            return jwt_decode<JwtClaims>(token);\n        }\n        catch (err) {\n            Logger.error(\"JwtUtils.decode\", err);\n            throw err;\n        }\n    }\n}\n","/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/open#window_features\n *\n * @public\n */\nexport interface PopupWindowFeatures {\n    left?: number;\n    top?: number;\n    width?: number;\n    height?: number;\n    menubar?: boolean | string;\n    toolbar?: boolean | string;\n    location?: boolean | string;\n    status?: boolean | string;\n    resizable?: boolean | string;\n    scrollbars?: boolean | string;\n\n    [k: string]: boolean | string | number | undefined;\n}\n\nexport class PopupUtils {\n    /**\n     * Populates a map of window features with a placement centered in front of\n     * the current window. If no explicit width is given, a default value is\n     * binned into [800, 720, 600, 480, 360] based on the current window's width.\n     */\n    static center({ ...features }: PopupWindowFeatures): PopupWindowFeatures {\n        if (features.width == null)\n            features.width = [800, 720, 600, 480].find(width => width <= window.outerWidth / 1.618) ?? 360;\n        features.left ??= Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n        if (features.height != null)\n            features.top ??= Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n        return features;\n    }\n\n    static serialize(features: PopupWindowFeatures): string {\n        return Object.entries(features)\n            .filter(([, value]) => value != null)\n            .map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value as string : value ? \"yes\" : \"no\"}`)\n            .join(\",\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event } from \"./Event\";\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport class Timer extends Event<[void]> {\n    protected readonly _logger = new Logger(`Timer('${this._name}')`);\n    private _timerHandle: ReturnType<typeof setInterval> | null = null;\n    private _expiration = 0;\n\n    // get the time\n    public static getEpochTime(): number {\n        return Math.floor(Date.now() / 1000);\n    }\n\n    public init(durationInSeconds: number): void {\n        const logger = this._logger.create(\"init\");\n        durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n        const expiration = Timer.getEpochTime() + durationInSeconds;\n        if (this.expiration === expiration && this._timerHandle) {\n            // no need to reinitialize to same expiration, so bail out\n            logger.debug(\"skipping since already initialized for expiration at\", this.expiration);\n            return;\n        }\n\n        this.cancel();\n\n        logger.debug(\"using duration\", durationInSeconds);\n        this._expiration = expiration;\n\n        // we're using a fairly short timer and then checking the expiration in the\n        // callback to handle scenarios where the browser device sleeps, and then\n        // the timers end up getting delayed.\n        const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n        this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1000);\n    }\n\n    public get expiration(): number {\n        return this._expiration;\n    }\n\n    public cancel(): void {\n        this._logger.create(\"cancel\");\n        if (this._timerHandle) {\n            clearInterval(this._timerHandle);\n            this._timerHandle = null;\n        }\n    }\n\n    protected _callback = (): void => {\n        const diff = this._expiration - Timer.getEpochTime();\n        this._logger.debug(\"timer completes in\", diff);\n\n        if (this._expiration <= Timer.getEpochTime()) {\n            this.cancel();\n            super.raise();\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * @internal\n */\nexport class UrlUtils {\n    public static readParams(url: string, responseMode: \"query\" | \"fragment\" = \"query\"): URLSearchParams {\n        if (!url) throw new TypeError(\"Invalid URL\");\n        const parsedUrl = new URL(url, window.location.origin);\n        const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n        return new URLSearchParams(params.slice(1));\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\n\n/**\n * Error class thrown in case of an authentication error.\n *\n * See https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n *\n * @public\n */\nexport class ErrorResponse extends Error {\n    /** Marker to detect class: \"ErrorResponse\" */\n    public readonly name: string = \"ErrorResponse\";\n\n    /** An error code string that can be used to classify the types of errors that occur and to respond to errors. */\n    public readonly error: string | null;\n    /** additional information that can help a developer identify the cause of the error.*/\n    public readonly error_description: string | null;\n    /**\n     * URI identifying a human-readable web page with information about the error, used to provide the client\n       developer with additional information about the error.\n    */\n    public readonly error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public state?: unknown;\n\n    public readonly session_state: string | null;\n\n    public constructor(\n        args: {\n            error?: string | null; error_description?: string | null; error_uri?: string | null;\n            userState?: unknown; session_state?: string | null;\n        },\n        /** The x-www-form-urlencoded request body sent to the authority server */\n        public readonly form?: URLSearchParams,\n    ) {\n        super(args.error_description || args.error || \"\");\n\n        if (!args.error) {\n            Logger.error(\"ErrorResponse\", \"No error passed\");\n            throw new Error(\"No error passed\");\n        }\n\n        this.error = args.error;\n        this.error_description = args.error_description ?? null;\n        this.error_uri = args.error_uri ?? null;\n\n        this.state = args.userState;\n        this.session_state = args.session_state ?? null;\n    }\n}\n","// Copyright (C) 2021 AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Error class thrown in case of network timeouts (e.g IFrame time out).\n *\n * @public\n */\nexport class ErrorTimeout extends Error {\n    /** Marker to detect class: \"ErrorTimeout\" */\n    public readonly name: string = \"ErrorTimeout\";\n\n    public constructor(message?: string) {\n        super(message);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type AccessTokenCallback = (...ev: unknown[]) => (Promise<void> | void);\n\n/**\n * @public\n */\nexport class AccessTokenEvents {\n    protected readonly _logger = new Logger(\"AccessTokenEvents\");\n\n    private readonly _expiringTimer = new Timer(\"Access token expiring\");\n    private readonly _expiredTimer = new Timer(\"Access token expired\");\n    private readonly _expiringNotificationTimeInSeconds: number;\n\n    public constructor(args: { expiringNotificationTimeInSeconds: number }) {\n        this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n    }\n\n    public load(container: User): void {\n        const logger = this._logger.create(\"load\");\n        // only register events if there's an access token and it has an expiration\n        if (container.access_token && container.expires_in !== undefined) {\n            const duration = container.expires_in;\n            logger.debug(\"access token present, remaining duration:\", duration);\n\n            if (duration > 0) {\n                // only register expiring if we still have time\n                let expiring = duration - this._expiringNotificationTimeInSeconds;\n                if (expiring <= 0) {\n                    expiring = 1;\n                }\n\n                logger.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n                this._expiringTimer.init(expiring);\n            }\n            else {\n                logger.debug(\"canceling existing expiring timer because we're past expiration.\");\n                this._expiringTimer.cancel();\n            }\n\n            // if it's negative, it will still fire\n            const expired = duration + 1;\n            logger.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n            this._expiredTimer.init(expired);\n        }\n        else {\n            this._expiringTimer.cancel();\n            this._expiredTimer.cancel();\n        }\n    }\n\n    public unload(): void {\n        this._logger.debug(\"unload: canceling existing access token timers\");\n        this._expiringTimer.cancel();\n        this._expiredTimer.cancel();\n    }\n\n    /**\n     * Add callback: Raised prior to the access token expiring.\n     */\n    public addAccessTokenExpiring(cb: AccessTokenCallback): () => void {\n        return this._expiringTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised prior to the access token expiring.\n     */\n    public removeAccessTokenExpiring(cb: AccessTokenCallback): void {\n        this._expiringTimer.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised after the access token has expired.\n     */\n    public addAccessTokenExpired(cb: AccessTokenCallback): () => void {\n        return this._expiredTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised after the access token has expired.\n     */\n    public removeAccessTokenExpired(cb: AccessTokenCallback): void {\n        this._expiredTimer.removeHandler(cb);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @internal\n */\nexport class CheckSessionIFrame {\n    private readonly _logger = new Logger(\"CheckSessionIFrame\");\n    private _frame_origin: string;\n    private _frame: HTMLIFrameElement;\n    private _timer: ReturnType<typeof setInterval> | null = null;\n    private _session_state: string | null = null;\n\n    public constructor(\n        private _callback: () => Promise<void>,\n        private _client_id: string,\n        url: string,\n        private _intervalInSeconds: number,\n        private _stopOnError: boolean,\n    ) {\n        const parsedUrl = new URL(url);\n        this._frame_origin = parsedUrl.origin;\n\n        this._frame = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        this._frame.style.visibility = \"hidden\";\n        this._frame.style.position = \"fixed\";\n        this._frame.style.left = \"-1000px\";\n        this._frame.style.top = \"0\";\n        this._frame.width = \"0\";\n        this._frame.height = \"0\";\n        this._frame.src = parsedUrl.href;\n    }\n\n    public load(): Promise<void> {\n        return new Promise<void>((resolve) => {\n            this._frame.onload = () => {\n                resolve();\n            };\n\n            window.document.body.appendChild(this._frame);\n            window.addEventListener(\"message\", this._message, false);\n        });\n    }\n\n    private _message = (e: MessageEvent<string>): void => {\n        if (e.origin === this._frame_origin &&\n            e.source === this._frame.contentWindow\n        ) {\n            if (e.data === \"error\") {\n                this._logger.error(\"error message from check session op iframe\");\n                if (this._stopOnError) {\n                    this.stop();\n                }\n            }\n            else if (e.data === \"changed\") {\n                this._logger.debug(\"changed message from check session op iframe\");\n                this.stop();\n                void this._callback();\n            }\n            else {\n                this._logger.debug(e.data + \" message from check session op iframe\");\n            }\n        }\n    };\n\n    public start(session_state: string): void {\n        if (this._session_state === session_state) {\n            return;\n        }\n\n        this._logger.create(\"start\");\n\n        this.stop();\n\n        this._session_state = session_state;\n\n        const send = () => {\n            if (!this._frame.contentWindow || !this._session_state) {\n                return;\n            }\n\n            this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n        };\n\n        // trigger now\n        send();\n\n        // and setup timer\n        this._timer = setInterval(send, this._intervalInSeconds * 1000);\n    }\n\n    public stop(): void {\n        this._logger.create(\"stop\");\n        this._session_state = null;\n\n        if (this._timer) {\n\n            clearInterval(this._timer);\n            this._timer = null;\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @public\n */\nexport class InMemoryWebStorage implements Storage {\n    private readonly _logger = new Logger(\"InMemoryWebStorage\");\n    private _data: Record<string, string> = {};\n\n    public clear(): void {\n        this._logger.create(\"clear\");\n        this._data = {};\n    }\n\n    public getItem(key: string): string {\n        this._logger.create(`getItem('${key}')`);\n        return this._data[key];\n    }\n\n    public setItem(key: string, value: string): void {\n        this._logger.create(`setItem('${key}')`);\n        this._data[key] = value;\n    }\n\n    public removeItem(key: string): void {\n        this._logger.create(`removeItem('${key}')`);\n        delete this._data[key];\n    }\n\n    public get length(): number {\n        return Object.getOwnPropertyNames(this._data).length;\n    }\n\n    public key(index: number): string {\n        return Object.getOwnPropertyNames(this._data)[index];\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { ErrorResponse, ErrorTimeout } from \"./errors\";\nimport { Logger } from \"./utils\";\n\n/**\n * @internal\n */\nexport type JwtHandler = (text: string) => Promise<Record<string, unknown>>;\n\n/**\n * @internal\n */\nexport interface GetJsonOpts {\n    token?: string;\n    credentials?: RequestCredentials;\n}\n\n/**\n * @internal\n */\nexport interface PostFormOpts {\n    body: URLSearchParams;\n    basicAuth?: string;\n    timeoutInSeconds?: number;\n    initCredentials?: \"same-origin\" | \"include\" | \"omit\";\n}\n\n/**\n * @internal\n */\nexport class JsonService {\n    private readonly _logger = new Logger(\"JsonService\");\n\n    private _contentTypes: string[] = [];\n\n    public constructor(\n        additionalContentTypes: string[] = [],\n        private _jwtHandler: JwtHandler | null = null,\n    ) {\n        this._contentTypes.push(...additionalContentTypes, \"application/json\");\n        if (_jwtHandler) {\n            this._contentTypes.push(\"application/jwt\");\n        }\n    }\n\n    protected async fetchWithTimeout(input: RequestInfo, init: RequestInit & { timeoutInSeconds?: number } = {}) {\n        const { timeoutInSeconds, ...initFetch } = init;\n        if (!timeoutInSeconds) {\n            return await fetch(input, initFetch);\n        }\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1000);\n\n        try {\n            const response = await fetch(input, {\n                ...init,\n                signal: controller.signal,\n            });\n            return response;\n        }\n        catch (err) {\n            if (err instanceof DOMException && err.name === \"AbortError\") {\n                throw new ErrorTimeout(\"Network timed out\");\n            }\n            throw err;\n        }\n        finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    public async getJson(url: string, {\n        token,\n        credentials,\n    }: GetJsonOpts = {}): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"getJson\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n        };\n        if (token) {\n            logger.debug(\"token passed, setting Authorization header\");\n            headers[\"Authorization\"] = \"Bearer \" + token;\n        }\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"GET\", headers, credentials });\n        }\n        catch (err) {\n            logger.error(\"Network Error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            logger.throw(new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`));\n        }\n        if (response.ok && this._jwtHandler && contentType?.startsWith(\"application/jwt\")) {\n            return await this._jwtHandler(await response.text());\n        }\n        let json: Record<string, unknown>;\n        try {\n            json = await response.json();\n        }\n        catch (err) {\n            logger.error(\"Error parsing JSON response\", err);\n            if (response.ok) throw err;\n            throw new Error(`${response.statusText} (${response.status})`);\n        }\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (json.error) {\n                throw new ErrorResponse(json);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n        return json;\n    }\n\n    public async postForm(url: string, {\n        body,\n        basicAuth,\n        timeoutInSeconds,\n        initCredentials,\n    }: PostFormOpts): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"postForm\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n        };\n        if (basicAuth !== undefined) {\n            headers[\"Authorization\"] = \"Basic \" + basicAuth;\n        }\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n        }\n        catch (err) {\n            logger.error(\"Network error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            throw new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`);\n        }\n\n        const responseText = await response.text();\n\n        let json: Record<string, unknown> = {};\n        if (responseText) {\n            try {\n                json = JSON.parse(responseText);\n            }\n            catch (err) {\n                logger.error(\"Error parsing JSON response\", err);\n                if (response.ok) throw err;\n                throw new Error(`${response.statusText} (${response.status})`);\n            }\n        }\n\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (json.error) {\n                throw new ErrorResponse(json, body);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n\n        return json;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { OidcClientSettingsStore, SigningKey } from \"./OidcClientSettings\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\n\n/**\n * @public\n */\nexport class MetadataService {\n    private readonly _logger = new Logger(\"MetadataService\");\n    private readonly _jsonService = new JsonService([\"application/jwk-set+json\"]);\n\n    // cache\n    private _metadataUrl: string;\n    private _signingKeys: SigningKey[] | null = null;\n    private _metadata: Partial<OidcMetadata> | null = null;\n    private _fetchRequestCredentials: RequestCredentials | undefined;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore) {\n        this._metadataUrl = this._settings.metadataUrl;\n\n        if (this._settings.signingKeys) {\n            this._logger.debug(\"using signingKeys from settings\");\n            this._signingKeys = this._settings.signingKeys;\n        }\n\n        if (this._settings.metadata) {\n            this._logger.debug(\"using metadata from settings\");\n            this._metadata = this._settings.metadata;\n        }\n\n        if (this._settings.fetchRequestCredentials) {\n            this._logger.debug(\"using fetchRequestCredentials from settings\");\n            this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n        }\n    }\n\n    public resetSigningKeys(): void {\n        this._signingKeys = null;\n    }\n\n    public async getMetadata(): Promise<Partial<OidcMetadata>> {\n        const logger = this._logger.create(\"getMetadata\");\n        if (this._metadata) {\n            logger.debug(\"using cached values\");\n            return this._metadata;\n        }\n\n        if (!this._metadataUrl) {\n            logger.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n            throw null;\n        }\n\n        logger.debug(\"getting metadata from\", this._metadataUrl);\n        const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials });\n\n        logger.debug(\"merging remote JSON with seed metadata\");\n        this._metadata = Object.assign({}, this._settings.metadataSeed, metadata);\n        return this._metadata;\n    }\n\n    public getIssuer(): Promise<string> {\n        return this._getMetadataProperty(\"issuer\") as Promise<string>;\n    }\n\n    public getAuthorizationEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"authorization_endpoint\") as Promise<string>;\n    }\n\n    public getUserInfoEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"userinfo_endpoint\") as Promise<string>;\n    }\n\n    public getTokenEndpoint(optional: false): Promise<string>;\n    public getTokenEndpoint(optional?: true): Promise<string | undefined>;\n    public getTokenEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"token_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getCheckSessionIframe(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"check_session_iframe\", true) as Promise<string | undefined>;\n    }\n\n    public getEndSessionEndpoint(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"end_session_endpoint\", true) as Promise<string | undefined>;\n    }\n\n    public getRevocationEndpoint(optional: false): Promise<string>;\n    public getRevocationEndpoint(optional?: true): Promise<string | undefined>;\n    public getRevocationEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"revocation_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getKeysEndpoint(optional: false): Promise<string>;\n    public getKeysEndpoint(optional?: true): Promise<string | undefined>;\n    public getKeysEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"jwks_uri\", optional) as Promise<string | undefined>;\n    }\n\n    protected async _getMetadataProperty(name: keyof OidcMetadata, optional=false): Promise<string | boolean | string[] | undefined> {\n        const logger = this._logger.create(`_getMetadataProperty('${name}')`);\n\n        const metadata = await this.getMetadata();\n        logger.debug(\"resolved\");\n\n        if (metadata[name] === undefined) {\n            if (optional === true) {\n                logger.warn(\"Metadata does not contain optional property\");\n                return undefined;\n            }\n\n            logger.throw(new Error(\"Metadata does not contain property \" + name));\n        }\n\n        return metadata[name];\n    }\n\n    public async getSigningKeys(): Promise<SigningKey[] | null> {\n        const logger = this._logger.create(\"getSigningKeys\");\n        if (this._signingKeys) {\n            logger.debug(\"returning signingKeys from cache\");\n            return this._signingKeys;\n        }\n\n        const jwks_uri = await this.getKeysEndpoint(false);\n        logger.debug(\"got jwks_uri\", jwks_uri);\n\n        const keySet = await this._jsonService.getJson(jwks_uri);\n        logger.debug(\"got key set\", keySet);\n\n        if (!Array.isArray(keySet.keys)) {\n            logger.throw(new Error(\"Missing keys on keyset\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        this._signingKeys = keySet.keys;\n        return this._signingKeys;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\nimport type { AsyncStorage } from \"./AsyncStorage\";\n\n/**\n * @public\n */\nexport class WebStorageStateStore implements StateStore {\n    private readonly _logger = new Logger(\"WebStorageStateStore\");\n\n    private readonly _store: AsyncStorage | Storage;\n    private readonly _prefix: string;\n\n    public constructor({\n        prefix = \"oidc.\",\n        store = localStorage,\n    }: { prefix?: string; store?: AsyncStorage | Storage } = {}) {\n        this._store = store;\n        this._prefix = prefix;\n    }\n\n    public async set(key: string, value: string): Promise<void> {\n        this._logger.create(`set('${key}')`);\n\n        key = this._prefix + key;\n        await this._store.setItem(key, value);\n    }\n\n    public async get(key: string): Promise<string | null> {\n        this._logger.create(`get('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        return item;\n    }\n\n    public async remove(key: string): Promise<string | null> {\n        this._logger.create(`remove('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        await this._store.removeItem(key);\n        return item;\n    }\n\n    public async getAllKeys(): Promise<string[]> {\n        this._logger.create(\"getAllKeys\");\n        const len = await this._store.length;\n\n        const keys = [];\n        for (let index = 0; index < len; index++) {\n            const key = await this._store.key(index);\n            if (key && key.indexOf(this._prefix) === 0) {\n                keys.push(key.substr(this._prefix.length));\n            }\n        }\n        return keys;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\nimport type { StateStore } from \"./StateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\n\nconst DefaultResponseType = \"code\";\nconst DefaultScope = \"openid\";\nconst DefaultClientAuthentication = \"client_secret_post\";\nconst DefaultResponseMode = \"query\";\nconst DefaultStaleStateAgeInSeconds = 60 * 15;\nconst DefaultClockSkewInSeconds = 60 * 5;\n\n/**\n * @public\n */\nexport type SigningKey = Record<string, string | string[]>;\n\n/**\n * The settings used to configure the {@link OidcClient}.\n *\n * @public\n */\nexport interface OidcClientSettings {\n    /** The URL of the OIDC/OAuth2 provider */\n    authority: string;\n    metadataUrl?: string;\n    /** Provide metadata when authority server does not allow CORS on the metadata endpoint */\n    metadata?: Partial<OidcMetadata>;\n    /** Can be used to seed or add additional values to the results of the discovery request */\n    metadataSeed?: Partial<OidcMetadata>;\n    /** Provide signingKeys when authority server does not allow CORS on the jwks uri */\n    signingKeys?: SigningKey[];\n\n    /** Your client application's identifier as registered with the OIDC/OAuth2 */\n    client_id: string;\n    client_secret?: string;\n    /** The type of response desired from the OIDC/OAuth2 provider (default: \"code\") */\n    response_type?: string;\n    /** The scope being requested from the OIDC/OAuth2 provider (default: \"openid\") */\n    scope?: string;\n    /** The redirect URI of your client application to receive a response from the OIDC/OAuth2 provider */\n    redirect_uri: string;\n    /** The OIDC/OAuth2 post-logout redirect URI */\n    post_logout_redirect_uri?: string;\n\n    /**\n     * Client authentication method that is used to authenticate when using the token endpoint (default: \"client_secret_post\")\n     * - \"client_secret_basic\": using the HTTP Basic authentication scheme\n     * - \"client_secret_post\": including the client credentials in the request body\n     *\n     * See https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication\n     */\n    client_authentication?: \"client_secret_basic\" | \"client_secret_post\";\n\n    /** optional protocol param */\n    prompt?: string;\n    /** optional protocol param */\n    display?: string;\n    /** optional protocol param */\n    max_age?: number;\n    /** optional protocol param */\n    ui_locales?: string;\n    /** optional protocol param */\n    acr_values?: string;\n    /** optional protocol param */\n    resource?: string;\n\n    /** optional protocol param (default: \"query\") */\n    response_mode?: \"query\" | \"fragment\";\n\n    /** Should OIDC protocol claims be removed from profile (default: true) */\n    filterProtocolClaims?: boolean;\n    /** Flag to control if additional identity data is loaded from the user info endpoint in order to populate the user's profile (default: false) */\n    loadUserInfo?: boolean;\n    /** Number (in seconds) indicating the age of state entries in storage for authorize requests that are considered abandoned and thus can be cleaned up (default: 300) */\n    staleStateAgeInSeconds?: number;\n\n    /** @deprecated Unused */\n    clockSkewInSeconds?: number;\n    /** @deprecated Unused */\n    userInfoJwtIssuer?: \"ANY\" | \"OP\" | string;\n\n    /**\n     * Indicates if objects returned from the user info endpoint as claims (e.g. `address`) are merged into the claims from the id token as a single object.\n     * Otherwise, they are added to an array as distinct objects for the claim type. (default: false)\n     */\n    mergeClaims?: boolean;\n\n    /**\n     * Storage object used to persist interaction state (default: window.localStorage, InMemoryWebStorage iff no window).\n     * E.g. `stateStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    stateStore?: StateStore;\n\n    /**\n     * An object containing additional query string parameters to be including in the authorization request.\n     * E.g, when using Azure AD to obtain an access token an additional resource parameter is required. extraQueryParams: `{resource:\"some_identifier\"}`\n     */\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    extraTokenParams?: Record<string, unknown>;\n\n    /**\n     * @deprecated since version 2.1.0. Use fetchRequestCredentials instead.\n     */\n    refreshTokenCredentials?: \"same-origin\" | \"include\" | \"omit\";\n\n    /**\n     * Will check the content type header of the response of the revocation endpoint to match these passed values (default: [])\n     */\n    revokeTokenAdditionalContentTypes?: string[];\n\n    /**\n     * Sets the credentials for fetch requests. (default: \"same-origin\")\n     * Use this if you need to send cookies to the OIDC/OAuth2 provider or if you are using a proxy that requires cookies\n     */\n    fetchRequestCredentials?: RequestCredentials;\n}\n\n/**\n * The settings with defaults applied of the {@link OidcClient}.\n * @see {@link OidcClientSettings}\n *\n * @public\n */\nexport class OidcClientSettingsStore {\n    // metadata\n    public readonly authority: string;\n    public readonly metadataUrl: string;\n    public readonly metadata: Partial<OidcMetadata> | undefined;\n    public readonly metadataSeed: Partial<OidcMetadata> | undefined;\n    public readonly signingKeys: SigningKey[] | undefined;\n\n    // client config\n    public readonly client_id: string;\n    public readonly client_secret: string | undefined;\n    public readonly response_type: string;\n    public readonly scope: string;\n    public readonly redirect_uri: string;\n    public readonly post_logout_redirect_uri: string | undefined;\n    public readonly client_authentication: \"client_secret_basic\" | \"client_secret_post\";\n\n    // optional protocol params\n    public readonly prompt: string | undefined;\n    public readonly display: string | undefined;\n    public readonly max_age: number | undefined;\n    public readonly ui_locales: string | undefined;\n    public readonly acr_values: string | undefined;\n    public readonly resource: string | undefined;\n    public readonly response_mode: \"query\" | \"fragment\";\n\n    // behavior flags\n    public readonly filterProtocolClaims: boolean;\n    public readonly loadUserInfo: boolean;\n    public readonly staleStateAgeInSeconds: number;\n    public readonly clockSkewInSeconds: number;\n    public readonly userInfoJwtIssuer: \"ANY\" | \"OP\" | string;\n    public readonly mergeClaims: boolean;\n\n    public readonly stateStore: StateStore;\n\n    // extra\n    public readonly extraQueryParams: Record<string, string | number | boolean>;\n    public readonly extraTokenParams: Record<string, unknown>;\n\n    public readonly revokeTokenAdditionalContentTypes?: string[];\n    public readonly fetchRequestCredentials: RequestCredentials;\n\n    public constructor({\n        // metadata related\n        authority, metadataUrl, metadata, signingKeys, metadataSeed,\n        // client related\n        client_id, client_secret, response_type = DefaultResponseType, scope = DefaultScope,\n        redirect_uri, post_logout_redirect_uri,\n        client_authentication = DefaultClientAuthentication,\n        // optional protocol\n        prompt, display, max_age, ui_locales, acr_values, resource, response_mode = DefaultResponseMode,\n        // behavior flags\n        filterProtocolClaims = true,\n        loadUserInfo = false,\n        staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n        clockSkewInSeconds = DefaultClockSkewInSeconds,\n        userInfoJwtIssuer = \"OP\",\n        mergeClaims = false,\n        // other behavior\n        stateStore,\n        refreshTokenCredentials,\n        revokeTokenAdditionalContentTypes,\n        fetchRequestCredentials,\n        // extra query params\n        extraQueryParams = {},\n        extraTokenParams = {},\n    }: OidcClientSettings) {\n\n        this.authority = authority;\n\n        if (metadataUrl) {\n            this.metadataUrl = metadataUrl;\n        } else {\n            this.metadataUrl = authority;\n            if (authority) {\n                if (!this.metadataUrl.endsWith(\"/\")) {\n                    this.metadataUrl += \"/\";\n                }\n                this.metadataUrl += \".well-known/openid-configuration\";\n            }\n        }\n\n        this.metadata = metadata;\n        this.metadataSeed = metadataSeed;\n        this.signingKeys = signingKeys;\n\n        this.client_id = client_id;\n        this.client_secret = client_secret;\n        this.response_type = response_type;\n        this.scope = scope;\n        this.redirect_uri = redirect_uri;\n        this.post_logout_redirect_uri = post_logout_redirect_uri;\n        this.client_authentication = client_authentication;\n\n        this.prompt = prompt;\n        this.display = display;\n        this.max_age = max_age;\n        this.ui_locales = ui_locales;\n        this.acr_values = acr_values;\n        this.resource = resource;\n        this.response_mode = response_mode;\n\n        this.filterProtocolClaims = !!filterProtocolClaims;\n        this.loadUserInfo = !!loadUserInfo;\n        this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n        this.clockSkewInSeconds = clockSkewInSeconds;\n        this.userInfoJwtIssuer = userInfoJwtIssuer;\n        this.mergeClaims = !!mergeClaims;\n\n        this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n\n        if (fetchRequestCredentials && refreshTokenCredentials) {\n            console.warn(\"Both fetchRequestCredentials and refreshTokenCredentials is set. Only fetchRequestCredentials will be used.\");\n        }\n        this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials\n            : refreshTokenCredentials ? refreshTokenCredentials : \"same-origin\";\n\n        if (stateStore) {\n            this.stateStore = stateStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n            this.stateStore = new WebStorageStateStore({ store });\n        }\n\n        this.extraQueryParams = extraQueryParams;\n        this.extraTokenParams = extraTokenParams;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { JwtClaims } from \"./Claims\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport class UserInfoService {\n    protected readonly _logger = new Logger(\"UserInfoService\");\n    private readonly _jsonService: JsonService;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(undefined, this._getClaimsFromJwt);\n    }\n\n    public async getClaims(token: string): Promise<JwtClaims> {\n        const logger = this._logger.create(\"getClaims\");\n        if (!token) {\n            this._logger.throw(new Error(\"No token passed\"));\n        }\n\n        const url = await this._metadataService.getUserInfoEndpoint();\n        logger.debug(\"got userinfo url\", url);\n\n        const claims = await this._jsonService.getJson(url, {\n            token,\n            credentials: this._settings.fetchRequestCredentials,\n        });\n        logger.debug(\"got claims\", claims);\n\n        return claims;\n    }\n\n    protected _getClaimsFromJwt = async (responseText: string): Promise<JwtClaims> => {\n        const logger = this._logger.create(\"_getClaimsFromJwt\");\n        try {\n            const payload = JwtUtils.decode(responseText);\n            logger.debug(\"JWT decoding successful\");\n\n            return payload;\n        } catch (err) {\n            logger.error(\"Error parsing JWT response\");\n            throw err;\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport interface ExchangeCodeArgs {\n    client_id?: string;\n    client_secret?: string;\n    redirect_uri?: string;\n\n    grant_type?: string;\n    code: string;\n    code_verifier?: string;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeCredentialsArgs {\n    client_id?: string;\n    client_secret?: string;\n\n    grant_type?: string;\n    scope?: string;\n\n    username: string;\n    password: string;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeRefreshTokenArgs {\n    client_id?: string;\n    client_secret?: string;\n\n    grant_type?: string;\n    refresh_token: string;\n    scope?: string;\n\n    timeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport interface RevokeArgs {\n    token: string;\n    token_type_hint?: \"access_token\" | \"refresh_token\";\n}\n\n/**\n * @internal\n */\nexport class TokenClient {\n    private readonly _logger = new Logger(\"TokenClient\");\n    private readonly _jsonService;\n\n    public constructor(\n        private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(this._settings.revokeTokenAdditionalContentTypes);\n    }\n\n    public async exchangeCode({\n        grant_type = \"authorization_code\",\n        redirect_uri = this._settings.redirect_uri,\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        ...args\n    }: ExchangeCodeArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCode\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!redirect_uri) {\n            logger.throw(new Error(\"A redirect_uri is required\"));\n        }\n        if (!args.code) {\n            logger.throw(new Error(\"A code is required\"));\n        }\n        if (!args.code_verifier) {\n            logger.throw(new Error(\"A code_verifier is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type, redirect_uri });\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    public async exchangeCredentials({\n        grant_type = \"password\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        scope = this._settings.scope,\n        username,\n        password,\n    }: ExchangeCredentialsArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCredentials\");\n\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type, username, password, scope });\n\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    public async exchangeRefreshToken({\n        grant_type = \"refresh_token\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        timeoutInSeconds,\n        ...args\n    }: ExchangeRefreshTokenArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeRefreshToken\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!args.refresh_token) {\n            logger.throw(new Error(\"A refresh_token is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type });\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        let basicAuth: string | undefined;\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                if (!client_secret) {\n                    logger.throw(new Error(\"A client_secret is required\"));\n                    throw null; // https://github.com/microsoft/TypeScript/issues/46972\n                }\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n        }\n\n        const url = await this._metadataService.getTokenEndpoint(false);\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Revoke an access or refresh token.\n     *\n     * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n     */\n    public async revoke(args: RevokeArgs): Promise<void> {\n        const logger = this._logger.create(\"revoke\");\n        if (!args.token) {\n            logger.throw(new Error(\"A token is required\"));\n        }\n\n        const url = await this._metadataService.getRevocationEndpoint(false);\n\n        logger.debug(`got revocation endpoint, revoking ${args.token_type_hint ?? \"default token type\"}`);\n\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        params.set(\"client_id\", this._settings.client_id);\n        if (this._settings.client_secret) {\n            params.set(\"client_secret\", this._settings.client_secret);\n        }\n\n        await this._jsonService.postForm(url, { body: params });\n        logger.debug(\"got response\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { UserInfoService } from \"./UserInfoService\";\nimport { TokenClient } from \"./TokenClient\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { SigninState } from \"./SigninState\";\nimport type { SigninResponse } from \"./SigninResponse\";\nimport type { State } from \"./State\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { UserProfile } from \"./User\";\nimport type { RefreshState } from \"./RefreshState\";\nimport type { JwtClaims, IdTokenClaims } from \"./Claims\";\n\n/**\n * Derived from the following sets of claims:\n * - {@link https://datatracker.ietf.org/doc/html/rfc7519.html#section-4.1}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#IDToken}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken}\n *\n * @internal\n */\nconst ProtocolClaims = [\n    \"iss\",\n    // \"sub\" should never be excluded, we need access to it internally\n    \"aud\",\n    \"exp\",\n    \"nbf\",\n    \"iat\",\n    \"jti\",\n    \"auth_time\",\n    \"nonce\",\n    \"acr\",\n    \"amr\",\n    \"azp\",\n    // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n    \"at_hash\",\n] as const;\n\n/**\n * @internal\n */\nexport class ResponseValidator {\n    protected readonly _logger = new Logger(\"ResponseValidator\");\n    protected readonly _userInfoService = new UserInfoService(this._settings, this._metadataService);\n    protected readonly _tokenClient = new TokenClient(this._settings, this._metadataService);\n\n    public constructor(\n        protected readonly _settings: OidcClientSettingsStore,\n        protected readonly _metadataService: MetadataService,\n    ) {}\n\n    public async validateSigninResponse(response: SigninResponse, state: SigninState): Promise<void> {\n        const logger = this._logger.create(\"validateSigninResponse\");\n\n        this._processSigninState(response, state);\n        logger.debug(\"state processed\");\n\n        await this._processCode(response, state);\n        logger.debug(\"code processed\");\n\n        if (response.isOpenId) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, state?.skipUserInfo, response.isOpenId);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateCredentialsResponse(response: SigninResponse, skipUserInfo: boolean): Promise<void> {\n        const logger = this._logger.create(\"validateCredentialsResponse\");\n\n        if (response.isOpenId) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, skipUserInfo, response.isOpenId);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateRefreshResponse(response: SigninResponse, state: RefreshState): Promise<void> {\n        const logger = this._logger.create(\"validateRefreshResponse\");\n\n        response.userState = state.data;\n        // if there's no session_state on the response, copy over session_state from original request\n        response.session_state ??= state.session_state;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        // OpenID Connect Core 1.0 says that id_token is optional in refresh response:\n        // https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokenResponse\n        if (response.isOpenId && !!response.id_token) {\n            this._validateIdTokenAttributes(response, state.id_token);\n            logger.debug(\"ID Token validated\");\n        }\n\n        if (!response.id_token) {\n            // if there's no id_token on the response, copy over id_token from original request\n            response.id_token = state.id_token;\n            // and decoded part too\n            response.profile = state.profile;\n        }\n\n        const hasIdToken = response.isOpenId && !!response.id_token;\n        await this._processClaims(response, false, hasIdToken);\n        logger.debug(\"claims processed\");\n    }\n\n    public validateSignoutResponse(response: SignoutResponse, state: State): void {\n        const logger = this._logger.create(\"validateSignoutResponse\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n    }\n\n    protected _processSigninState(response: SigninResponse, state: SigninState): void {\n        const logger = this._logger.create(\"_processSigninState\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        if (!state.client_id) {\n            logger.throw(new Error(\"No client_id on state\"));\n        }\n\n        if (!state.authority) {\n            logger.throw(new Error(\"No authority on state\"));\n        }\n\n        // ensure we're using the correct authority\n        if (this._settings.authority !== state.authority) {\n            logger.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n        }\n        if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n            logger.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n\n        if (state.code_verifier && !response.code) {\n            logger.throw(new Error(\"Expected code in response\"));\n        }\n\n        if (!state.code_verifier && response.code) {\n            logger.throw(new Error(\"Unexpected code in response\"));\n        }\n    }\n\n    protected async _processClaims(response: SigninResponse, skipUserInfo = false, validateSub = true): Promise<void> {\n        const logger = this._logger.create(\"_processClaims\");\n        response.profile = this._filterProtocolClaims(response.profile);\n\n        if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n            logger.debug(\"not loading user info\");\n            return;\n        }\n\n        logger.debug(\"loading user info\");\n        const claims = await this._userInfoService.getClaims(response.access_token);\n        logger.debug(\"user info claims received from user info endpoint\");\n\n        if (validateSub && claims.sub !== response.profile.sub) {\n            logger.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n        }\n\n        response.profile = this._mergeClaims(response.profile, this._filterProtocolClaims(claims as IdTokenClaims));\n        logger.debug(\"user info claims received, updated profile:\", response.profile);\n    }\n\n    protected _mergeClaims(claims1: UserProfile, claims2: JwtClaims): UserProfile {\n        const result = { ...claims1 };\n\n        for (const [claim, values] of Object.entries(claims2)) {\n            for (const value of Array.isArray(values) ? values : [values]) {\n                const previousValue = result[claim];\n                if (!previousValue) {\n                    result[claim] = value;\n                }\n                else if (Array.isArray(previousValue)) {\n                    if (!previousValue.includes(value)) {\n                        previousValue.push(value);\n                    }\n                }\n                else if (result[claim] !== value) {\n                    if (typeof value === \"object\" && this._settings.mergeClaims) {\n                        result[claim] = this._mergeClaims(previousValue as UserProfile, value);\n                    }\n                    else {\n                        result[claim] = [previousValue, value];\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    protected _filterProtocolClaims(claims: UserProfile): UserProfile {\n        const result = { ...claims };\n\n        if (this._settings.filterProtocolClaims) {\n            for (const type of ProtocolClaims) {\n                delete result[type];\n            }\n        }\n\n        return result;\n    }\n\n    protected async _processCode(response: SigninResponse, state: SigninState): Promise<void> {\n        const logger = this._logger.create(\"_processCode\");\n        if (response.code) {\n            logger.debug(\"Validating code\");\n            const tokenResponse = await this._tokenClient.exchangeCode({\n                client_id: state.client_id,\n                client_secret: state.client_secret,\n                code: response.code,\n                redirect_uri: state.redirect_uri,\n                code_verifier: state.code_verifier,\n                ...state.extraTokenParams,\n            });\n            Object.assign(response, tokenResponse);\n        } else {\n            logger.debug(\"No code to process\");\n        }\n    }\n\n    protected _validateIdTokenAttributes(response: SigninResponse, currentToken?: string): void {\n        const logger = this._logger.create(\"_validateIdTokenAttributes\");\n\n        logger.debug(\"decoding ID Token JWT\");\n        const profile = JwtUtils.decode(response.id_token ?? \"\");\n\n        if (!profile.sub) {\n            logger.throw(new Error(\"ID Token is missing a subject claim\"));\n        }\n\n        if (currentToken) {\n            const current = JwtUtils.decode(currentToken);\n            if (current.sub !== profile.sub) {\n                logger.throw(new Error(\"sub in id_token does not match current sub\"));\n            }\n            if (current.auth_time && current.auth_time !== profile.auth_time) {\n                logger.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n            }\n            if (current.azp && current.azp !== profile.azp) {\n                logger.throw(new Error(\"azp in id_token does not match original azp\"));\n            }\n            if (!current.azp && profile.azp) {\n                logger.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n            }\n        }\n\n        response.profile = profile as UserProfile;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils, Timer } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\n\n/**\n * @public\n */\nexport class State {\n    public readonly id: string;\n    public readonly created: number;\n    public readonly request_type: string | undefined;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data: unknown | undefined;\n\n    public constructor(args: {\n        id?: string;\n        data?: unknown;\n        created?: number;\n        request_type?: string;\n    }) {\n        this.id = args.id || CryptoUtils.generateUUIDv4();\n        this.data = args.data;\n\n        if (args.created && args.created > 0) {\n            this.created = args.created;\n        }\n        else {\n            this.created = Timer.getEpochTime();\n        }\n        this.request_type = args.request_type;\n    }\n\n    public toStorageString(): string {\n        new Logger(\"State\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n        });\n    }\n\n    public static fromStorageString(storageString: string): State {\n        Logger.createStatic(\"State\", \"fromStorageString\");\n        return new State(JSON.parse(storageString));\n    }\n\n    public static async clearStaleState(storage: StateStore, age: number): Promise<void> {\n        const logger = Logger.createStatic(\"State\", \"clearStaleState\");\n        const cutoff = Timer.getEpochTime() - age;\n\n        const keys = await storage.getAllKeys();\n        logger.debug(\"got keys\", keys);\n\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const item = await storage.get(key);\n            let remove = false;\n\n            if (item) {\n                try {\n                    const state = State.fromStorageString(item);\n\n                    logger.debug(\"got item from key:\", key, state.created);\n                    if (state.created <= cutoff) {\n                        remove = true;\n                    }\n                }\n                catch (err) {\n                    logger.error(\"Error parsing state for key:\", key, err);\n                    remove = true;\n                }\n            }\n            else {\n                logger.debug(\"no item in storage for key:\", key);\n                remove = true;\n            }\n\n            if (remove) {\n                logger.debug(\"removed item for key:\", key);\n                void storage.remove(key);\n            }\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils } from \"./utils\";\nimport { State } from \"./State\";\n\n/**\n * @public\n */\nexport class SigninState extends State {\n    // isCode\n    /** The same code_verifier that was used to obtain the authorization_code via PKCE. */\n    public readonly code_verifier: string | undefined;\n    /** Used to secure authorization code grants via Proof Key for Code Exchange (PKCE). */\n    public readonly code_challenge: string | undefined;\n\n    // to ensure state still matches settings\n    /** @see {@link OidcClientSettings.authority} */\n    public readonly authority: string;\n    /** @see {@link OidcClientSettings.client_id} */\n    public readonly client_id: string;\n    /** @see {@link OidcClientSettings.redirect_uri} */\n    public readonly redirect_uri: string;\n    /** @see {@link OidcClientSettings.scope} */\n    public readonly scope: string;\n    /** @see {@link OidcClientSettings.client_secret} */\n    public readonly client_secret: string | undefined;\n    /** @see {@link OidcClientSettings.extraTokenParams} */\n    public readonly extraTokenParams: Record<string, unknown> | undefined;\n    /** @see {@link OidcClientSettings.response_mode} */\n    public readonly response_mode: \"query\" | \"fragment\" | undefined;\n\n    public readonly skipUserInfo: boolean | undefined;\n\n    public constructor(args: {\n        id?: string;\n        data?: unknown;\n        created?: number;\n        request_type?: string;\n\n        code_verifier?: string | boolean;\n        authority: string;\n        client_id: string;\n        redirect_uri: string;\n        scope: string;\n        client_secret?: string;\n        extraTokenParams?: Record<string, unknown>;\n        response_mode?: \"query\" | \"fragment\";\n        skipUserInfo?: boolean;\n    }) {\n        super(args);\n\n        if (args.code_verifier === true) {\n            this.code_verifier = CryptoUtils.generateCodeVerifier();\n        }\n        else if (args.code_verifier) {\n            this.code_verifier = args.code_verifier;\n        }\n\n        if (this.code_verifier) {\n            this.code_challenge = CryptoUtils.generateCodeChallenge(this.code_verifier);\n        }\n\n        this.authority = args.authority;\n        this.client_id = args.client_id;\n        this.redirect_uri = args.redirect_uri;\n        this.scope = args.scope;\n        this.client_secret = args.client_secret;\n        this.extraTokenParams = args.extraTokenParams;\n\n        this.response_mode = args.response_mode;\n        this.skipUserInfo = args.skipUserInfo;\n    }\n\n    public toStorageString(): string {\n        new Logger(\"SigninState\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n\n            code_verifier: this.code_verifier,\n            authority: this.authority,\n            client_id: this.client_id,\n            redirect_uri: this.redirect_uri,\n            scope: this.scope,\n            client_secret: this.client_secret,\n            extraTokenParams : this.extraTokenParams,\n            response_mode: this.response_mode,\n            skipUserInfo: this.skipUserInfo,\n        });\n    }\n\n    public static fromStorageString(storageString: string): SigninState {\n        Logger.createStatic(\"SigninState\", \"fromStorageString\");\n        const data = JSON.parse(storageString);\n        return new SigninState(data);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { SigninState } from \"./SigninState\";\n\n/**\n * @public\n */\nexport interface SigninRequestArgs {\n    // mandatory\n    url: string;\n    authority: string;\n    client_id: string;\n    redirect_uri: string;\n    response_type: string;\n    scope: string;\n\n    // optional\n    prompt?: string;\n    display?: string;\n    max_age?: number;\n    ui_locales?: string;\n    id_token_hint?: string;\n    login_hint?: string;\n    acr_values?: string;\n    resource?: string;\n    response_mode?: \"query\" | \"fragment\" ;\n    request?: string;\n    request_uri?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n    request_type?: string;\n    client_secret?: string;\n    extraTokenParams?: Record<string, unknown>;\n    skipUserInfo?: boolean;\n    nonce?: string; \n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state_data?: unknown;\n}\n\n/**\n * @public\n */\nexport class SigninRequest {\n    private readonly _logger = new Logger(\"SigninRequest\");\n\n    public readonly url: string;\n    public readonly state: SigninState;\n\n    public constructor({\n        // mandatory\n        url, authority, client_id, redirect_uri, response_type, scope,\n        // optional\n        state_data, response_mode, request_type, client_secret, nonce,\n        skipUserInfo,\n        extraQueryParams,\n        extraTokenParams,\n        ...optionalParams\n    }: SigninRequestArgs) {\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n        if (!client_id) {\n            this._logger.error(\"ctor: No client_id passed\");\n            throw new Error(\"client_id\");\n        }\n        if (!redirect_uri) {\n            this._logger.error(\"ctor: No redirect_uri passed\");\n            throw new Error(\"redirect_uri\");\n        }\n        if (!response_type) {\n            this._logger.error(\"ctor: No response_type passed\");\n            throw new Error(\"response_type\");\n        }\n        if (!scope) {\n            this._logger.error(\"ctor: No scope passed\");\n            throw new Error(\"scope\");\n        }\n        if (!authority) {\n            this._logger.error(\"ctor: No authority passed\");\n            throw new Error(\"authority\");\n        }\n\n        this.state = new SigninState({\n            data: state_data,\n            request_type,\n            code_verifier: true,\n            client_id, authority, redirect_uri,\n            response_mode,\n            client_secret, scope, extraTokenParams,\n            skipUserInfo,\n        });\n\n        const parsedUrl = new URL(url);\n        parsedUrl.searchParams.append(\"client_id\", client_id);\n        parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n        parsedUrl.searchParams.append(\"response_type\", response_type);\n        parsedUrl.searchParams.append(\"scope\", scope);\n        if (nonce) {\n            parsedUrl.searchParams.append(\"nonce\", nonce);\n        }\n\n        parsedUrl.searchParams.append(\"state\", this.state.id);\n        if (this.state.code_challenge) {\n            parsedUrl.searchParams.append(\"code_challenge\", this.state.code_challenge);\n            parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n        }\n\n        for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        this.url = parsedUrl.href;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Timer } from \"./utils\";\nimport type { UserProfile } from \"./User\";\n\nconst OidcScope = \"openid\";\n\n/**\n * @public\n */\nexport class SigninResponse {\n    // props present in the initial callback response regardless of success\n    public readonly state: string | null;\n    /** @see {@link User.session_state} */\n    public session_state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public readonly error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public readonly error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public readonly error_uri: string | null;\n\n    // success props\n    public readonly code: string | null;\n\n    // props set after validation\n    /** @see {@link User.id_token} */\n    public id_token?: string;\n    /** @see {@link User.access_token} */\n    public access_token = \"\";\n    /** @see {@link User.token_type} */\n    public token_type = \"\";\n    /** @see {@link User.refresh_token} */\n    public refresh_token?: string;\n    /** @see {@link User.scope} */\n    public scope?: string;\n    /** @see {@link User.expires_at} */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n\n    /** @see {@link User.profile} */\n    public profile: UserProfile = {} as UserProfile;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n        this.session_state = params.get(\"session_state\");\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n\n        this.code = params.get(\"code\");\n    }\n\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n    public set expires_in(value: number | undefined) {\n        // spec expects a number, but normalize here just in case\n        if (typeof value === \"string\") value = Number(value);\n        if (value !== undefined && value >= 0) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    public get isOpenId(): boolean {\n        return this.scope?.split(\" \").includes(OidcScope) || !!this.id_token;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { State } from \"./State\";\n\n/**\n * @public\n */\nexport interface SignoutRequestArgs {\n    // mandatory\n    url: string;\n\n    // optional\n    state_data?: unknown;\n    id_token_hint?: string;\n    post_logout_redirect_uri?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n    request_type?: string;\n}\n\n/**\n * @public\n */\nexport class SignoutRequest {\n    private readonly _logger = new Logger(\"SignoutRequest\");\n\n    public readonly url: string;\n    public readonly state?: State;\n\n    public constructor({\n        url,\n        state_data, id_token_hint, post_logout_redirect_uri, extraQueryParams, request_type,\n    }: SignoutRequestArgs) {\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n\n        const parsedUrl = new URL(url);\n        if (id_token_hint) {\n            parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n        }\n\n        if (post_logout_redirect_uri) {\n            parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n\n            if (state_data) {\n                this.state = new State({ data: state_data, request_type });\n\n                parsedUrl.searchParams.append(\"state\", this.state.id);\n            }\n        }\n\n        for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        this.url = parsedUrl.href;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * @public\n */\nexport class SignoutResponse {\n    public readonly state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, UrlUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport { ResponseValidator } from \"./ResponseValidator\";\nimport { MetadataService } from \"./MetadataService\";\nimport type { RefreshState } from \"./RefreshState\";\nimport { SigninRequest } from \"./SigninRequest\";\nimport { SigninResponse } from \"./SigninResponse\";\nimport { SignoutRequest, SignoutRequestArgs } from \"./SignoutRequest\";\nimport { SignoutResponse } from \"./SignoutResponse\";\nimport { SigninState } from \"./SigninState\";\nimport { State } from \"./State\";\nimport { TokenClient } from \"./TokenClient\";\n\n/**\n * @public\n */\nexport interface CreateSigninRequestArgs {\n    redirect_uri?: string;\n    response_type?: string;\n    scope?: string;\n    nonce?: string;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state?: unknown;\n\n    prompt?: string;\n    display?: string;\n    max_age?: number;\n    ui_locales?: string;\n    id_token_hint?: string;\n    login_hint?: string;\n    acr_values?: string;\n    resource?: string;\n    response_mode?: \"query\" | \"fragment\";\n    request?: string;\n    request_uri?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n    request_type?: string;\n    client_secret?: string;\n    extraTokenParams?: Record<string, unknown>;\n    skipUserInfo?: boolean;\n}\n\n/**\n * @public\n */\nexport interface UseRefreshTokenArgs {\n    state: RefreshState;\n    timeoutInSeconds?: number;\n}\n\n/**\n * @public\n */\nexport type CreateSignoutRequestArgs = Omit<SignoutRequestArgs, \"url\" | \"state_data\"> & { state?: unknown };\n\n/**\n * @public\n */\nexport type ProcessResourceOwnerPasswordCredentialsArgs = {\n    username: string;\n    password: string;\n    skipUserInfo?: boolean;\n};\n\n/**\n * Provides the raw OIDC/OAuth2 protocol support for the authorization endpoint and the end session endpoint in the\n * authorization server. It provides a bare-bones protocol implementation and is used by the UserManager class.\n * Only use this class if you simply want protocol support without the additional management features of the\n * UserManager class.\n *\n * @public\n */\nexport class OidcClient {\n    public readonly settings: OidcClientSettingsStore;\n    protected readonly _logger = new Logger(\"OidcClient\");\n\n    public readonly metadataService: MetadataService;\n    protected readonly _validator: ResponseValidator;\n    protected readonly _tokenClient: TokenClient;\n\n    public constructor(settings: OidcClientSettings) {\n        this.settings = new OidcClientSettingsStore(settings);\n\n        this.metadataService = new MetadataService(this.settings);\n        this._validator = new ResponseValidator(this.settings, this.metadataService);\n        this._tokenClient = new TokenClient(this.settings, this.metadataService);\n    }\n\n    public async createSigninRequest({\n        state,\n        request,\n        request_uri,\n        request_type,\n        id_token_hint,\n        login_hint,\n        skipUserInfo,\n        nonce,\n        response_type = this.settings.response_type,\n        scope = this.settings.scope,\n        redirect_uri = this.settings.redirect_uri,\n        prompt = this.settings.prompt,\n        display = this.settings.display,\n        max_age = this.settings.max_age,\n        ui_locales = this.settings.ui_locales,\n        acr_values = this.settings.acr_values,\n        resource = this.settings.resource,\n        response_mode = this.settings.response_mode,\n        extraQueryParams = this.settings.extraQueryParams,\n        extraTokenParams = this.settings.extraTokenParams,\n    }: CreateSigninRequestArgs): Promise<SigninRequest> {\n        const logger = this._logger.create(\"createSigninRequest\");\n\n        if (response_type !== \"code\") {\n            throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n        }\n\n        const url = await this.metadataService.getAuthorizationEndpoint();\n        logger.debug(\"Received authorization endpoint\", url);\n\n        const signinRequest = new SigninRequest({\n            url,\n            authority: this.settings.authority,\n            client_id: this.settings.client_id,\n            redirect_uri,\n            response_type,\n            scope,\n            state_data: state,\n            prompt, display, max_age, ui_locales, id_token_hint, login_hint, acr_values,\n            resource, request, request_uri, extraQueryParams, extraTokenParams, request_type, response_mode,\n            client_secret: this.settings.client_secret,\n            skipUserInfo,\n            nonce,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signinState = signinRequest.state;\n        await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n        return signinRequest;\n    }\n\n    public async readSigninResponseState(url: string, removeState = false): Promise<{ state: SigninState; response: SigninResponse }> {\n        const logger = this._logger.create(\"readSigninResponseState\");\n\n        const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.throw(new Error(\"No state in response\"));\n            // need to throw within this function's body for type narrowing to work\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = SigninState.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSigninResponse(url: string): Promise<SigninResponse> {\n        const logger = this._logger.create(\"processSigninResponse\");\n\n        const { state, response } = await this.readSigninResponseState(url, true);\n        logger.debug(\"received state from storage; validating response\");\n        await this._validator.validateSigninResponse(response, state);\n        return response;\n    }\n\n    public async processResourceOwnerPasswordCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n    }: ProcessResourceOwnerPasswordCredentialsArgs): Promise<SigninResponse> {\n        const tokenResponse: Record<string, unknown> = await this._tokenClient.exchangeCredentials({ username, password });\n        const signinResponse: SigninResponse = new SigninResponse(new URLSearchParams());\n        Object.assign(signinResponse, tokenResponse);\n        await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n        return signinResponse;\n    }\n\n    public async useRefreshToken({\n        state,\n        timeoutInSeconds,\n    }: UseRefreshTokenArgs): Promise<SigninResponse> {\n        const logger = this._logger.create(\"useRefreshToken\");\n\n        const result = await this._tokenClient.exchangeRefreshToken({\n            refresh_token: state.refresh_token,\n            scope: state.scope,\n            timeoutInSeconds,\n        });\n        const response = new SigninResponse(new URLSearchParams());\n        Object.assign(response, result);\n        logger.debug(\"validating response\", response);\n        await this._validator.validateRefreshResponse(response, state);\n        return response;\n    }\n\n    public async createSignoutRequest({\n        state,\n        id_token_hint,\n        request_type,\n        post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n        extraQueryParams = this.settings.extraQueryParams,\n    }: CreateSignoutRequestArgs = {}): Promise<SignoutRequest> {\n        const logger = this._logger.create(\"createSignoutRequest\");\n\n        const url = await this.metadataService.getEndSessionEndpoint();\n        if (!url) {\n            logger.throw(new Error(\"No end session endpoint\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        logger.debug(\"Received end session endpoint\", url);\n\n        const request = new SignoutRequest({\n            url,\n            id_token_hint,\n            post_logout_redirect_uri,\n            state_data: state,\n            extraQueryParams,\n            request_type,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signoutState = request.state;\n        if (signoutState) {\n            logger.debug(\"Signout request has state to persist\");\n            await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n        }\n\n        return request;\n    }\n\n    public async readSignoutResponseState(url: string, removeState = false): Promise<{ state: State | undefined; response: SignoutResponse }> {\n        const logger = this._logger.create(\"readSignoutResponseState\");\n\n        const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.debug(\"No state in response\");\n\n            if (response.error) {\n                logger.warn(\"Response was error:\", response.error);\n                throw new ErrorResponse(response);\n            }\n\n            return { state: undefined, response };\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = State.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSignoutResponse(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"processSignoutResponse\");\n\n        const { state, response } = await this.readSignoutResponseState(url, true);\n        if (state) {\n            logger.debug(\"Received state from storage; validating response\");\n            this._validator.validateSignoutResponse(response, state);\n        } else {\n            logger.debug(\"No state from storage; skipping response validation\");\n        }\n\n        return response;\n    }\n\n    public clearStaleState(): Promise<void> {\n        this._logger.create(\"clearStaleState\");\n        return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n    }\n\n    public async revokeToken(token: string, type?: \"access_token\" | \"refresh_token\"): Promise<void> {\n        this._logger.create(\"revokeToken\");\n        return await this._tokenClient.revoke({\n            token,\n            token_type_hint: type,\n        });\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { CheckSessionIFrame } from \"./CheckSessionIFrame\";\nimport type { UserManager } from \"./UserManager\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport class SessionMonitor {\n    private readonly _logger = new Logger(\"SessionMonitor\");\n\n    private _sub: string | undefined;\n    private _sid: string | undefined;\n    private _checkSessionIFrame?: CheckSessionIFrame;\n\n    public constructor(private readonly _userManager: UserManager) {\n        if (!_userManager) {\n            this._logger.throw(new Error(\"No user manager passed\"));\n        }\n\n        this._userManager.events.addUserLoaded(this._start);\n        this._userManager.events.addUserUnloaded(this._stop);\n\n        this._init().catch((err: unknown) => {\n            // catch to suppress errors since we're in a ctor\n            this._logger.error(err);\n        });\n    }\n\n    protected async _init(): Promise<void> {\n        this._logger.create(\"_init\");\n        const user = await this._userManager.getUser();\n        // doing this manually here since calling getUser\n        // doesn't trigger load event.\n        if (user) {\n            void this._start(user);\n        }\n        else if (this._userManager.settings.monitorAnonymousSession) {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n                const tmpUser = {\n                    session_state: session.session_state,\n                    profile: session.sub && session.sid ? {\n                        sub: session.sub,\n                        sid: session.sid,\n                    } : null,\n                };\n                void this._start(tmpUser);\n            }\n        }\n    }\n\n    protected _start = async (\n        user: User | {\n            session_state: string;\n            profile: { sub: string; sid: string } | null;\n        },\n    ): Promise<void> => {\n        const session_state = user.session_state;\n        if (!session_state) {\n            return;\n        }\n        const logger = this._logger.create(\"_start\");\n\n        if (user.profile) {\n            this._sub = user.profile.sub;\n            this._sid = user.profile.sid;\n            logger.debug(\"session_state\", session_state, \", sub\", this._sub);\n        }\n        else {\n            this._sub = undefined;\n            this._sid = undefined;\n            logger.debug(\"session_state\", session_state, \", anonymous user\");\n        }\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.start(session_state);\n            return;\n        }\n\n        try {\n            const url = await this._userManager.metadataService.getCheckSessionIframe();\n            if (url) {\n                logger.debug(\"initializing check session iframe\");\n\n                const client_id = this._userManager.settings.client_id;\n                const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n                const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n\n                const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n                await checkSessionIFrame.load();\n                this._checkSessionIFrame = checkSessionIFrame;\n                checkSessionIFrame.start(session_state);\n            }\n            else {\n                logger.warn(\"no check session iframe found in the metadata\");\n            }\n        }\n        catch (err) {\n            // catch to suppress errors since we're in non-promise callback\n            logger.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n        }\n    };\n\n    protected _stop = (): void => {\n        const logger = this._logger.create(\"_stop\");\n        this._sub = undefined;\n        this._sid = undefined;\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.stop();\n        }\n\n        if (this._userManager.settings.monitorAnonymousSession) {\n            // using a timer to delay re-initialization to avoid race conditions during signout\n            // TODO rewrite to use promise correctly\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            const timerHandle = setInterval(async () => {\n                clearInterval(timerHandle);\n\n                try {\n                    const session = await this._userManager.querySessionStatus();\n                    if (session) {\n                        const tmpUser = {\n                            session_state: session.session_state,\n                            profile: session.sub && session.sid ? {\n                                sub: session.sub,\n                                sid: session.sid,\n                            } : null,\n                        };\n                        void this._start(tmpUser);\n                    }\n                }\n                catch (err) {\n                    // catch to suppress errors since we're in a callback\n                    logger.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n                }\n            }, 1000);\n        }\n    };\n\n    protected _callback = async (): Promise<void> => {\n        const logger = this._logger.create(\"_callback\");\n        try {\n            const session = await this._userManager.querySessionStatus();\n            let raiseEvent = true;\n\n            if (session && this._checkSessionIFrame) {\n                if (session.sub === this._sub) {\n                    raiseEvent = false;\n                    this._checkSessionIFrame.start(session.session_state);\n\n                    if (session.sid === this._sid) {\n                        logger.debug(\"same sub still logged in at OP, restarting check session iframe; session_state\", session.session_state);\n                    }\n                    else {\n                        logger.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n                        this._userManager.events._raiseUserSessionChanged();\n                    }\n                }\n                else {\n                    logger.debug(\"different subject signed into OP\", session.sub);\n                }\n            }\n            else {\n                logger.debug(\"subject no longer signed into OP\");\n            }\n\n            if (raiseEvent) {\n                if (this._sub) {\n                    this._userManager.events._raiseUserSignedOut();\n                }\n                else {\n                    this._userManager.events._raiseUserSignedIn();\n                }\n            } else {\n                logger.debug(\"no change in session detected, no event to raise\");\n            }\n        }\n        catch (err) {\n            if (this._sub) {\n                logger.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n                this._userManager.events._raiseUserSignedOut();\n            }\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { IdTokenClaims } from \"./Claims\";\n\n/**\n * Holds claims represented by a combination of the `id_token` and the user info endpoint.\n * @public\n */\nexport type UserProfile = IdTokenClaims;\n\n/**\n * @public\n */\nexport class User {\n    /**\n     * A JSON Web Token (JWT). Only provided if `openid` scope was requested.\n     * The application can access the data decoded by using the `profile` property.\n     */\n    public id_token?: string;\n\n    /** The session state value returned from the OIDC provider. */\n    public session_state: string | null;\n\n    /**\n     * The requested access token returned from the OIDC provider. The application can use this token to\n     * authenticate itself to the secured resource.\n     */\n    public access_token: string;\n\n    /**\n     * An OAuth 2.0 refresh token. The app can use this token to acquire additional access tokens after the\n     * current access token expires. Refresh tokens are long-lived and can be used to maintain access to resources\n     * for extended periods of time.\n     */\n    public refresh_token?: string;\n\n    /** Typically \"Bearer\" */\n    public token_type: string;\n\n    /** The scopes that the requested access token is valid for. */\n    public scope?: string;\n\n    /** The claims represented by a combination of the `id_token` and the user info endpoint. */\n    public profile: UserProfile;\n\n    /** The expires at returned from the OIDC provider. */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public readonly state: unknown;\n\n    public constructor(args: {\n        id_token?: string;\n        session_state?: string | null;\n        access_token: string;\n        refresh_token?: string;\n        token_type: string;\n        scope?: string;\n        profile: UserProfile;\n        expires_at?: number;\n        userState?: unknown;\n    }) {\n        this.id_token = args.id_token;\n        this.session_state = args.session_state ?? null;\n        this.access_token = args.access_token;\n        this.refresh_token = args.refresh_token;\n\n        this.token_type = args.token_type;\n        this.scope = args.scope;\n        this.profile = args.profile;\n        this.expires_at = args.expires_at;\n        this.state = args.userState;\n    }\n\n    /** Computed number of seconds the access token has remaining. */\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n\n    public set expires_in(value: number | undefined) {\n        if (value !== undefined) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    /** Computed value indicating if the access token is expired. */\n    public get expired(): boolean | undefined {\n        const expires_in = this.expires_in;\n        if (expires_in === undefined) {\n            return undefined;\n        }\n        return expires_in <= 0;\n    }\n\n    /** Array representing the parsed values from the `scope`. */\n    public get scopes(): string[] {\n        return this.scope?.split(\" \") ?? [];\n    }\n\n    public toStorageString(): string {\n        new Logger(\"User\").create(\"toStorageString\");\n        return JSON.stringify({\n            id_token: this.id_token,\n            session_state: this.session_state,\n            access_token: this.access_token,\n            refresh_token: this.refresh_token,\n            token_type: this.token_type,\n            scope: this.scope,\n            profile: this.profile,\n            expires_at: this.expires_at,\n        });\n    }\n\n    public static fromStorageString(storageString: string): User {\n        Logger.createStatic(\"User\", \"fromStorageString\");\n        return new User(JSON.parse(storageString));\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event, Logger, UrlUtils } from \"../utils\";\nimport type { IWindow, NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst messageSource = \"oidc-client\";\n\ninterface MessageData {\n    source: string;\n    url: string;\n    keepOpen: boolean;\n}\n\n/**\n * Window implementation which resolves via communication from a child window\n * via the `Window.postMessage()` interface.\n *\n * @internal\n */\nexport abstract class AbstractChildWindow implements IWindow {\n    protected abstract readonly _logger: Logger;\n    protected readonly _abort = new Event<[reason: Error]>(\"Window navigation aborted\");\n    protected readonly _disposeHandlers = new Set<() => void>();\n\n    protected _window: WindowProxy | null = null;\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"navigate\");\n        if (!this._window) {\n            throw new Error(\"Attempted to navigate on a disposed window\");\n        }\n\n        logger.debug(\"setting URL in window\");\n        this._window.location.replace(params.url);\n\n        const { url, keepOpen } = await new Promise<MessageData>((resolve, reject) => {\n            const listener = (e: MessageEvent) => {\n                const data: MessageData | undefined = e.data;\n                const origin = params.scriptOrigin ?? window.location.origin;\n                if (e.origin !== origin || data?.source !== messageSource) {\n                    // silently discard events not intended for us\n                    return;\n                }\n                try {\n                    const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n                    if (!state) {\n                        logger.warn(\"no state found in response url\");\n                    }\n                    if (e.source !== this._window && state !== params.state) {\n                        // MessageEvent source is a relatively modern feature, we can't rely on it\n                        // so we also inspect the payload for a matching state key as an alternative\n                        return;\n                    }\n                }\n                catch (err) {\n                    this._dispose();\n                    reject(new Error(\"Invalid response from window\"));\n                }\n                resolve(data);\n            };\n            window.addEventListener(\"message\", listener, false);\n            this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n            this._disposeHandlers.add(this._abort.addHandler((reason) => {\n                this._dispose();\n                reject(reason);\n            }));\n        });\n        logger.debug(\"got response from window\");\n        this._dispose();\n\n        if (!keepOpen) {\n            this.close();\n        }\n\n        return { url };\n    }\n\n    public abstract close(): void;\n\n    private _dispose(): void {\n        this._logger.create(\"_dispose\");\n\n        for (const dispose of this._disposeHandlers) {\n            dispose();\n        }\n        this._disposeHandlers.clear();\n    }\n\n    protected static _notifyParent(parent: Window, url: string, keepOpen = false, targetOrigin = window.location.origin): void {\n        parent.postMessage({\n            source: messageSource,\n            url,\n            keepOpen,\n        } as MessageData, targetOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { PopupWindowFeatures } from \"./utils/PopupUtils\";\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\n\nexport const DefaultPopupWindowFeatures: PopupWindowFeatures = {\n    location: false,\n    toolbar: false,\n    height: 640,\n};\nexport const DefaultPopupTarget = \"_blank\";\nconst DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nconst DefaultCheckSessionIntervalInSeconds = 2;\nexport const DefaultSilentRequestTimeoutInSeconds = 10;\n\n/**\n * The settings used to configure the {@link UserManager}.\n *\n * @public\n */\nexport interface UserManagerSettings extends OidcClientSettings {\n    /** The URL for the page containing the call to signinPopupCallback to handle the callback from the OIDC/OAuth2 */\n    popup_redirect_uri?: string;\n    popup_post_logout_redirect_uri?: string;\n    /**\n     * The features parameter to window.open for the popup signin window. By default, the popup is\n     * placed centered in front of the window opener.\n     * (default: \\{ location: false, menubar: false, height: 640 \\})\n     */\n    popupWindowFeatures?: PopupWindowFeatures;\n    /** The target parameter to window.open for the popup signin window (default: \"_blank\") */\n    popupWindowTarget?: string;\n    /** The methods window.location method used to redirect (default: \"assign\") */\n    redirectMethod?: \"replace\" | \"assign\";\n    /** The methods target window being redirected (default: \"self\") */\n    redirectTarget?: \"top\" | \"self\";\n\n    /** The target to pass while calling postMessage inside iframe for callback (default: window.location.origin) */\n    iframeNotifyParentOrigin?: string;\n\n    /** The script origin to check during 'message' callback execution while performing silent auth via iframe (default: window.location.origin) */\n    iframeScriptOrigin?: string;\n\n    /** The URL for the page containing the code handling the silent renew */\n    silent_redirect_uri?: string;\n    /** Number of seconds to wait for the silent renew to return before assuming it has failed or timed out (default: 10) */\n    silentRequestTimeoutInSeconds?: number;\n    /** Flag to indicate if there should be an automatic attempt to renew the access token prior to its expiration (default: true) */\n    automaticSilentRenew?: boolean;\n    /** Flag to validate user.profile.sub in silent renew calls (default: true) */\n    validateSubOnSilentRenew?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent renew calls (default: false) */\n    includeIdTokenInSilentRenew?: boolean;\n\n    /** Will raise events for when user has performed a signout at the OP (default: false) */\n    monitorSession?: boolean;\n    monitorAnonymousSession?: boolean;\n    /** Interval in seconds to check the user's session (default: 2) */\n    checkSessionIntervalInSeconds?: number;\n    query_status_response_type?: string;\n    stopCheckSessionOnError?: boolean;\n\n    /**\n     * The `token_type_hint`s to pass to the authority server by default (default: [\"access_token\", \"refresh_token\"])\n     *\n     * Token types will be revoked in the same order as they are given here.\n     */\n    revokeTokenTypes?: (\"access_token\" | \"refresh_token\")[];\n    /** Will invoke the revocation endpoint on signout if there is an access token for the user (default: false) */\n    revokeTokensOnSignout?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent signout calls (default: false) */\n    includeIdTokenInSilentSignout?: boolean;\n\n    /** The number of seconds before an access token is to expire to raise the accessTokenExpiring event (default: 60) */\n    accessTokenExpiringNotificationTimeInSeconds?: number;\n\n    /**\n     * Storage object used to persist User for currently authenticated user (default: window.sessionStorage, InMemoryWebStorage iff no window).\n     *  E.g. `userStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    userStore?: WebStorageStateStore;\n}\n\n/**\n * The settings with defaults applied of the {@link UserManager}.\n * @see {@link UserManagerSettings}\n *\n * @public\n */\nexport class UserManagerSettingsStore extends OidcClientSettingsStore {\n    public readonly popup_redirect_uri: string;\n    public readonly popup_post_logout_redirect_uri: string | undefined;\n    public readonly popupWindowFeatures: PopupWindowFeatures;\n    public readonly popupWindowTarget: string;\n    public readonly redirectMethod: \"replace\" | \"assign\";\n    public readonly redirectTarget: \"top\" | \"self\";\n\n    public readonly iframeNotifyParentOrigin: string | undefined;\n    public readonly iframeScriptOrigin: string | undefined;\n\n    public readonly silent_redirect_uri: string;\n    public readonly silentRequestTimeoutInSeconds: number;\n    public readonly automaticSilentRenew: boolean;\n    public readonly validateSubOnSilentRenew: boolean;\n    public readonly includeIdTokenInSilentRenew: boolean;\n\n    public readonly monitorSession: boolean;\n    public readonly monitorAnonymousSession: boolean;\n    public readonly checkSessionIntervalInSeconds: number;\n    public readonly query_status_response_type: string;\n    public readonly stopCheckSessionOnError: boolean;\n\n    public readonly revokeTokenTypes: (\"access_token\" | \"refresh_token\")[];\n    public readonly revokeTokensOnSignout: boolean;\n    public readonly includeIdTokenInSilentSignout: boolean;\n\n    public readonly accessTokenExpiringNotificationTimeInSeconds: number;\n\n    public readonly userStore: WebStorageStateStore;\n\n    public constructor(args: UserManagerSettings) {\n        const {\n            popup_redirect_uri = args.redirect_uri,\n            popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n            popupWindowFeatures = DefaultPopupWindowFeatures,\n            popupWindowTarget = DefaultPopupTarget,\n            redirectMethod = \"assign\",\n            redirectTarget = \"self\",\n\n            iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n            iframeScriptOrigin = args.iframeScriptOrigin,\n\n            silent_redirect_uri = args.redirect_uri,\n            silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n            automaticSilentRenew = true,\n            validateSubOnSilentRenew = true,\n            includeIdTokenInSilentRenew = false,\n\n            monitorSession = false,\n            monitorAnonymousSession = false,\n            checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n            query_status_response_type = \"code\",\n            stopCheckSessionOnError = true,\n\n            revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n            revokeTokensOnSignout = false,\n            includeIdTokenInSilentSignout = false,\n\n            accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n\n            userStore,\n        } = args;\n\n        super(args);\n\n        this.popup_redirect_uri = popup_redirect_uri;\n        this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n        this.popupWindowFeatures = popupWindowFeatures;\n        this.popupWindowTarget = popupWindowTarget;\n        this.redirectMethod = redirectMethod;\n        this.redirectTarget = redirectTarget;\n\n        this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n        this.iframeScriptOrigin = iframeScriptOrigin;\n\n        this.silent_redirect_uri = silent_redirect_uri;\n        this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds;\n        this.automaticSilentRenew = automaticSilentRenew;\n        this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n        this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n\n        this.monitorSession = monitorSession;\n        this.monitorAnonymousSession = monitorAnonymousSession;\n        this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n        this.stopCheckSessionOnError = stopCheckSessionOnError;\n        this.query_status_response_type = query_status_response_type;\n\n        this.revokeTokenTypes = revokeTokenTypes;\n        this.revokeTokensOnSignout = revokeTokensOnSignout;\n        this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n\n        this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n\n        if (userStore) {\n            this.userStore = userStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n            this.userStore = new WebStorageStateStore({ store });\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { ErrorTimeout } from \"../errors\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport { DefaultSilentRequestTimeoutInSeconds } from \"../UserManagerSettings\";\n\n/**\n * @public\n */\nexport interface IFrameWindowParams {\n    silentRequestTimeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport class IFrameWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"IFrameWindow\");\n    private _frame: HTMLIFrameElement | null;\n    private _timeoutInSeconds: number;\n\n    public constructor({\n        silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n    }: IFrameWindowParams) {\n        super();\n        this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n\n        this._frame = IFrameWindow.createHiddenIframe();\n        this._window = this._frame.contentWindow;\n    }\n\n    private static createHiddenIframe(): HTMLIFrameElement {\n        const iframe = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        iframe.style.visibility = \"hidden\";\n        iframe.style.position = \"fixed\";\n        iframe.style.left = \"-1000px\";\n        iframe.style.top = \"0\";\n        iframe.width = \"0\";\n        iframe.height = \"0\";\n        iframe.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n\n        window.document.body.appendChild(iframe);\n        return iframe;\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n        const timer = setTimeout(() => this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1000);\n        this._disposeHandlers.add(() => clearTimeout(timer));\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._frame) {\n            if (this._frame.parentNode) {\n                this._frame.addEventListener(\"load\", (ev) => {\n                    const frame = ev.target as HTMLIFrameElement;\n                    frame.parentNode?.removeChild(frame);\n                    this._abort.raise(new Error(\"IFrame removed from DOM\"));\n                }, true);\n                this._frame.contentWindow?.location.replace(\"about:blank\");\n            }\n            this._frame = null;\n        }\n        this._window = null;\n    }\n\n    public static notifyParent(url: string, targetOrigin?: string): void {\n        return super._notifyParent(window.parent, url, false, targetOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport { IFrameWindow, IFrameWindowParams } from \"./IFrameWindow\";\nimport type { INavigator } from \"./INavigator\";\n\n/**\n * @internal\n */\nexport class IFrameNavigator implements INavigator {\n    private readonly _logger = new Logger(\"IFrameNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds,\n    }: IFrameWindowParams): Promise<IFrameWindow> {\n        return new IFrameWindow({ silentRequestTimeoutInSeconds });\n    }\n\n    public async callback(url: string): Promise<void> {\n        this._logger.create(\"callback\");\n        IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, PopupUtils, PopupWindowFeatures } from \"../utils\";\nimport { DefaultPopupWindowFeatures, DefaultPopupTarget } from \"../UserManagerSettings\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst checkForPopupClosedInterval = 500;\n\n/**\n * @public\n */\nexport interface PopupWindowParams {\n    popupWindowFeatures?: PopupWindowFeatures;\n    popupWindowTarget?: string;\n}\n\n/**\n * @internal\n */\nexport class PopupWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"PopupWindow\");\n\n    protected _window: WindowProxy | null;\n\n    public constructor({\n        popupWindowTarget = DefaultPopupTarget,\n        popupWindowFeatures = {},\n    }: PopupWindowParams) {\n        super();\n        const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n        this._window = window.open(undefined, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._window?.focus();\n\n        const popupClosedInterval = setInterval(() => {\n            if (!this._window || this._window.closed) {\n                this._abort.raise(new Error(\"Popup closed by user\"));\n            }\n        }, checkForPopupClosedInterval);\n        this._disposeHandlers.add(() => clearInterval(popupClosedInterval));\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._window) {\n            if (!this._window.closed) {\n                this._window.close();\n                this._abort.raise(new Error(\"Popup closed\"));\n            }\n        }\n        this._window = null;\n    }\n\n    public static notifyOpener(url: string, keepOpen: boolean): void {\n        if (!window.opener) {\n            throw new Error(\"No window.opener. Can't complete notification.\");\n        }\n        return super._notifyParent(window.opener, url, keepOpen);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { PopupWindow, PopupWindowParams } from \"./PopupWindow\";\nimport type { INavigator } from \"./INavigator\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\n\n/**\n * @internal\n */\nexport class PopupNavigator implements INavigator {\n    private readonly _logger = new Logger(\"PopupNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        popupWindowFeatures = this._settings.popupWindowFeatures,\n        popupWindowTarget = this._settings.popupWindowTarget,\n    }: PopupWindowParams): Promise<PopupWindow> {\n        return new PopupWindow({ popupWindowFeatures, popupWindowTarget });\n    }\n\n    public async callback(url: string, keepOpen = false): Promise<void> {\n        this._logger.create(\"callback\");\n\n        PopupWindow.notifyOpener(url, keepOpen);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport type { INavigator } from \"./INavigator\";\nimport type { IWindow } from \"./IWindow\";\n\n/**\n * @public\n */\nexport interface RedirectParams {\n    redirectMethod?: \"replace\" | \"assign\";\n    redirectTarget?: \"top\" | \"self\";\n}\n\n/**\n * @internal\n */\nexport class RedirectNavigator implements INavigator {\n    private readonly _logger = new Logger(\"RedirectNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        redirectMethod = this._settings.redirectMethod,\n        redirectTarget = this._settings.redirectTarget,\n    }: RedirectParams): Promise<IWindow> {\n        this._logger.create(\"prepare\");\n        let targetWindow = window.self as Window;\n\n        if (redirectTarget === \"top\") {\n            targetWindow = window.top ?? window.self;\n        }\n    \n        const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location) as (url: string) => never;\n        let abort: (reason: Error) => void;\n        return {\n            navigate: async (params): Promise<never> => {\n                this._logger.create(\"navigate\");\n                // We use a promise that never resolves to block the caller\n                const promise = new Promise((resolve, reject) => {\n                    abort = reject;\n                });\n                redirect(params.url);\n                return await (promise as Promise<never>);\n            },\n            close: () => {\n                this._logger.create(\"close\");\n                abort?.(new Error(\"Redirect aborted\"));\n                targetWindow.stop();\n            },\n        };\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Event } from \"./utils\";\nimport { AccessTokenEvents } from \"./AccessTokenEvents\";\nimport type { UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type UserLoadedCallback = (user: User) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserUnloadedCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type SilentRenewErrorCallback = (error: Error) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedInCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedOutCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSessionChangedCallback = () => Promise<void> | void;\n\n/**\n * @public\n */\nexport class UserManagerEvents extends AccessTokenEvents {\n    protected readonly _logger = new Logger(\"UserManagerEvents\");\n\n    private readonly _userLoaded = new Event<[User]>(\"User loaded\");\n    private readonly _userUnloaded = new Event<[]>(\"User unloaded\");\n    private readonly _silentRenewError = new Event<[Error]>(\"Silent renew error\");\n    private readonly _userSignedIn = new Event<[]>(\"User signed in\");\n    private readonly _userSignedOut = new Event<[]>(\"User signed out\");\n    private readonly _userSessionChanged = new Event<[]>(\"User session changed\");\n\n    public constructor(settings: UserManagerSettingsStore) {\n        super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    }\n\n    public load(user: User, raiseEvent=true): void {\n        super.load(user);\n        if (raiseEvent) {\n            this._userLoaded.raise(user);\n        }\n    }\n    public unload(): void {\n        super.unload();\n        this._userUnloaded.raise();\n    }\n\n    /**\n     * Add callback: Raised when a user session has been established (or re-established).\n     */\n    public addUserLoaded(cb: UserLoadedCallback): () => void {\n        return this._userLoaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been established (or re-established).\n     */\n    public removeUserLoaded(cb: UserLoadedCallback): void {\n        return this._userLoaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when a user session has been terminated.\n     */\n    public addUserUnloaded(cb: UserUnloadedCallback): () => void {\n        return this._userUnloaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been terminated.\n     */\n    public removeUserUnloaded(cb: UserUnloadedCallback): void {\n        return this._userUnloaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when the automatic silent renew has failed.\n     */\n    public addSilentRenewError(cb: SilentRenewErrorCallback): () => void {\n        return this._silentRenewError.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the automatic silent renew has failed.\n     */\n    public removeSilentRenewError(cb: SilentRenewErrorCallback): void {\n        return this._silentRenewError.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseSilentRenewError(e: Error): void {\n        this._silentRenewError.raise(e);\n    }\n\n    /**\n     * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedIn(cb: UserSignedInCallback): () => void {\n        return this._userSignedIn.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n     */\n    public removeUserSignedIn(cb: UserSignedInCallback): void {\n        this._userSignedIn.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseUserSignedIn(): void {\n        this._userSignedIn.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedOut(cb: UserSignedOutCallback): () => void {\n        return this._userSignedOut.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     */\n    public removeUserSignedOut(cb: UserSignedOutCallback): void {\n        this._userSignedOut.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseUserSignedOut(): void {\n        this._userSignedOut.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user session changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSessionChanged(cb: UserSessionChangedCallback): () => void {\n        return this._userSessionChanged.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n     */\n    public removeUserSessionChanged(cb: UserSessionChangedCallback): void {\n        this._userSessionChanged.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public _raiseUserSessionChanged(): void {\n        this._userSessionChanged.raise();\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport { ErrorTimeout } from \"./errors\";\nimport type { UserManager } from \"./UserManager\";\nimport type { AccessTokenCallback } from \"./AccessTokenEvents\";\n\n/**\n * @internal\n */\nexport class SilentRenewService {\n    protected _logger = new Logger(\"SilentRenewService\");\n    private _isStarted = false;\n    private readonly _retryTimer = new Timer(\"Retry Silent Renew\");\n\n    public constructor(private _userManager: UserManager) {}\n\n    public async start(): Promise<void> {\n        const logger = this._logger.create(\"start\");\n        if (!this._isStarted) {\n            this._isStarted = true;\n            this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n            this._retryTimer.addHandler(this._tokenExpiring);\n\n            // this will trigger loading of the user so the expiring events can be initialized\n            try {\n                await this._userManager.getUser();\n                // deliberate nop\n            }\n            catch (err) {\n                // catch to suppress errors since we're in a ctor\n                logger.error(\"getUser error\", err);\n            }\n        }\n    }\n\n    public stop(): void {\n        if (this._isStarted) {\n            this._retryTimer.cancel();\n            this._retryTimer.removeHandler(this._tokenExpiring);\n            this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n            this._isStarted = false;\n        }\n    }\n\n    protected _tokenExpiring: AccessTokenCallback = async () => {\n        const logger = this._logger.create(\"_tokenExpiring\");\n        try {\n            await this._userManager.signinSilent();\n            logger.debug(\"silent token renewal successful\");\n        }\n        catch (err) {\n            if (err instanceof ErrorTimeout) {\n                // no response from authority server, e.g. IFrame timeout, ...\n                logger.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n                this._retryTimer.init(5);\n                return;\n            }\n\n            logger.error(\"Error from signinSilent:\", err);\n            this._userManager.events._raiseSilentRenewError(err as Error);\n        }\n    };\n}\n","// Copyright (C) AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport type { UserProfile } from \"./User\";\n\n/**\n * Fake state store implementation necessary for validating refresh token requests.\n *\n * @internal\n */\nexport class RefreshState {\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data: unknown | undefined;\n\n    public readonly refresh_token: string;\n    public readonly id_token?: string;\n    public readonly session_state: string | null;\n    public readonly scope?: string;\n    public readonly profile: UserProfile;\n\n    constructor(args: {\n        refresh_token: string;\n        id_token?: string;\n        session_state: string | null;\n        scope?: string;\n        profile: UserProfile;\n\n        state?: unknown;\n    }) {\n        this.refresh_token = args.refresh_token;\n        this.id_token = args.id_token;\n        this.session_state = args.session_state;\n        this.scope = args.scope;\n        this.profile = args.profile;\n\n        this.data = args.state;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { IFrameNavigator, NavigateResponse, PopupNavigator, RedirectNavigator, PopupWindowParams,\n    IWindow, IFrameWindowParams, RedirectParams } from \"./navigators\";\nimport { OidcClient, CreateSigninRequestArgs, CreateSignoutRequestArgs, ProcessResourceOwnerPasswordCredentialsArgs } from \"./OidcClient\";\nimport { UserManagerSettings, UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport { User } from \"./User\";\nimport { UserManagerEvents } from \"./UserManagerEvents\";\nimport { SilentRenewService } from \"./SilentRenewService\";\nimport { SessionMonitor } from \"./SessionMonitor\";\nimport type { SessionStatus } from \"./SessionStatus\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { RefreshState } from \"./RefreshState\";\nimport type { SigninResponse } from \"./SigninResponse\";\n\n/**\n * @public\n */\nexport type ExtraSigninRequestArgs = Pick<CreateSigninRequestArgs, \"nonce\" | \"extraQueryParams\" | \"extraTokenParams\" | \"state\" | \"redirect_uri\" | \"prompt\" | \"acr_values\">;\n/**\n * @public\n */\nexport type ExtraSignoutRequestArgs = Pick<CreateSignoutRequestArgs, \"extraQueryParams\" | \"state\" | \"id_token_hint\" | \"post_logout_redirect_uri\">;\n\n/**\n * @public\n */\nexport type RevokeTokensTypes = UserManagerSettings[\"revokeTokenTypes\"];\n\n/**\n * @public\n */\nexport type SigninRedirectArgs = RedirectParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninPopupArgs = PopupWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninSilentArgs = IFrameWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninResourceOwnerCredentialsArgs = ProcessResourceOwnerPasswordCredentialsArgs;\n\n/**\n * @public\n */\nexport type QuerySessionStatusArgs = IFrameWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutRedirectArgs = RedirectParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutPopupArgs = PopupWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutSilentArgs = IFrameWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * Provides a higher level API for signing a user in, signing out, managing the user's claims returned from the OIDC provider,\n * and managing an access token returned from the OIDC/OAuth2 provider.\n *\n * @public\n */\nexport class UserManager {\n    /** Returns the settings used to configure the `UserManager`. */\n    public readonly settings: UserManagerSettingsStore;\n    protected readonly _logger = new Logger(\"UserManager\");\n\n    protected readonly _client: OidcClient;\n    protected readonly _redirectNavigator: RedirectNavigator;\n    protected readonly _popupNavigator: PopupNavigator;\n    protected readonly _iframeNavigator: IFrameNavigator;\n    protected readonly _events: UserManagerEvents;\n    protected readonly _silentRenewService: SilentRenewService;\n    protected readonly _sessionMonitor: SessionMonitor | null;\n\n    public constructor(settings: UserManagerSettings) {\n        this.settings = new UserManagerSettingsStore(settings);\n\n        this._client = new OidcClient(settings);\n\n        this._redirectNavigator = new RedirectNavigator(this.settings);\n        this._popupNavigator = new PopupNavigator(this.settings);\n        this._iframeNavigator = new IFrameNavigator(this.settings);\n\n        this._events = new UserManagerEvents(this.settings);\n        this._silentRenewService = new SilentRenewService(this);\n\n        // order is important for the following properties; these services depend upon the events.\n        if (this.settings.automaticSilentRenew) {\n            this.startSilentRenew();\n        }\n\n        this._sessionMonitor = null;\n        if (this.settings.monitorSession) {\n            this._sessionMonitor = new SessionMonitor(this);\n        }\n\n    }\n\n    /** Returns an object used to register for events raised by the `UserManager`. */\n    public get events(): UserManagerEvents {\n        return this._events;\n    }\n\n    /** Returns an object used to access the metadata configuration of the OIDC provider. */\n    public get metadataService(): MetadataService {\n        return this._client.metadataService;\n    }\n\n    /**\n     * Returns promise to load the `User` object for the currently authenticated user.\n     */\n    public async getUser(): Promise<User | null> {\n        const logger = this._logger.create(\"getUser\");\n        const user = await this._loadUser();\n        if (user) {\n            logger.info(\"user loaded\");\n            this._events.load(user, false);\n            return user;\n        }\n\n        logger.info(\"user not found in storage\");\n        return null;\n    }\n\n    /**\n     * Returns promise to remove from any storage the currently authenticated user.\n     */\n    public async removeUser(): Promise<void> {\n        const logger = this._logger.create(\"removeUser\");\n        await this.storeUser(null);\n        logger.info(\"user removed from storage\");\n        this._events.unload();\n    }\n\n    /**\n     * Returns promise to trigger a redirect of the current window to the authorization endpoint.\n     */\n    public async signinRedirect(args: SigninRedirectArgs = {}): Promise<void> {\n        this._logger.create(\"signinRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signinStart({\n            request_type: \"si:r\",\n            ...requestArgs,\n        }, handle);\n    }\n\n    /**\n     * Returns promise to process response from the authorization endpoint. The result of the promise is the authenticated `User`.\n     */\n    public async signinRedirectCallback(url = window.location.href): Promise<User> {\n        const logger = this._logger.create(\"signinRedirectCallback\");\n        const user = await this._signinEnd(url);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        }\n        else {\n            logger.info(\"no subject\");\n        }\n\n        return user;\n    }\n\n    /**\n     * Returns promise to process the signin with user/password. The result of the promise is the authenticated `User`.\n     *\n     * Throws an ErrorResponse in case of wrong authentication.\n     */\n    public async signinResourceOwnerCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n    }: SigninResourceOwnerCredentialsArgs ) {\n        const logger = this._logger.create(\"signinResourceOwnerCredential\");\n\n        const signinResponse = await this._client.processResourceOwnerPasswordCredentials({ username, password, skipUserInfo });\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        } else {\n            logger.info(\"no subject\");\n        }\n        return user;\n    }\n\n    /**\n     * Returns promise to trigger a request (via a popup window) to the authorization endpoint. The result of the promise is the authenticated `User`.\n     */\n    public async signinPopup(args: SigninPopupArgs = {}): Promise<User> {\n        const logger = this._logger.create(\"signinPopup\");\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No popup_redirect_uri configured\"));\n        }\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n        const user = await this._signin({\n            request_type: \"si:p\",\n            redirect_uri: url,\n            display: \"popup\",\n            ...requestArgs,\n        }, handle);\n        if (user) {\n            if (user.profile && user.profile.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            }\n            else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n    /**\n     * Returns promise to notify the opening window of response from the authorization endpoint.\n     */\n    public async signinPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signinPopupCallback\");\n        await this._popupNavigator.callback(url, keepOpen);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to trigger a silent request (via an iframe) to the authorization endpoint.\n     * The result of the promise is the authenticated `User`.\n     */\n    public async signinSilent(args: SigninSilentArgs = {}): Promise<User | null> {\n        const logger = this._logger.create(\"signinSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        // first determine if we have a refresh token, or need to use iframe\n        let user = await this._loadUser();\n        if (user?.refresh_token) {\n            logger.debug(\"using refresh token\");\n            const state = new RefreshState(user as Required<User>);\n            return await this._useRefreshToken(state);\n        }\n\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        let verifySub: string | undefined;\n        if (user && this.settings.validateSubOnSilentRenew) {\n            logger.debug(\"subject prior to silent renew:\", user.profile.sub);\n            verifySub = user.profile.sub;\n        }\n\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        user = await this._signin({\n            request_type: \"si:s\",\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            ...requestArgs,\n        }, handle, verifySub);\n        if (user) {\n            if (user.profile?.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            }\n            else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n\n    protected async _useRefreshToken(state: RefreshState): Promise<User> {\n        const response = await this._client.useRefreshToken({\n            state,\n            timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds,\n        });\n        const user = new User({ ...state, ...response });\n\n        await this.storeUser(user);\n        this._events.load(user);\n        return user;\n    }\n\n    /**\n     * Returns promise to notify the parent window of response from the authorization endpoint.\n     */\n    public async signinSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signinSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    public async signinCallback(url = window.location.href): Promise<User | void> {\n        const { state } = await this._client.readSigninResponseState(url);\n        switch (state.request_type) {\n            case \"si:r\":\n                return await this.signinRedirectCallback(url);\n            case \"si:p\":\n                return await this.signinPopupCallback(url);\n            case \"si:s\":\n                return await this.signinSilentCallback(url);\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n    }\n\n    public async signoutCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const { state } = await this._client.readSignoutResponseState(url);\n        if (!state) {\n            return;\n        }\n\n        switch (state.request_type) {\n            case \"so:r\":\n                await this.signoutRedirectCallback(url);\n                break;\n            case \"so:p\":\n                await this.signoutPopupCallback(url, keepOpen);\n                break;\n            case \"so:s\":\n                await this.signoutSilentCallback(url);\n                break;\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n    }\n\n    /**\n     * Returns promise to query OP for user's current signin status. Returns object with session_state and subject identifier.\n     */\n    public async querySessionStatus(args: QuerySessionStatusArgs = {}): Promise<SessionStatus | null> {\n        const logger = this._logger.create(\"querySessionStatus\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        const user = await this._loadUser();\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        const navResponse = await this._signinStart({\n            request_type: \"si:s\", // this acts like a signin silent\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            response_type: this.settings.query_status_response_type,\n            scope: \"openid\",\n            skipUserInfo: true,\n            ...requestArgs,\n        }, handle);\n        try {\n            const signinResponse = await this._client.processSigninResponse(navResponse.url);\n            logger.debug(\"got signin response\");\n\n            if (signinResponse.session_state && signinResponse.profile.sub) {\n                logger.info(\"success for subject\", signinResponse.profile.sub);\n                return {\n                    session_state: signinResponse.session_state,\n                    sub: signinResponse.profile.sub,\n                    sid: signinResponse.profile.sid,\n                };\n            }\n\n            logger.info(\"success, user not authenticated\");\n            return null;\n        }\n        catch (err) {\n            if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n                switch (err.error) {\n                    case \"login_required\":\n                    case \"consent_required\":\n                    case \"interaction_required\":\n                    case \"account_selection_required\":\n                        logger.info(\"success for anonymous user\");\n                        return {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            session_state: err.session_state!,\n                        };\n                }\n            }\n            throw err;\n        }\n    }\n\n    protected async _signin(args: CreateSigninRequestArgs, handle: IWindow, verifySub?: string): Promise<User> {\n        const navResponse = await this._signinStart(args, handle);\n        return await this._signinEnd(navResponse.url, verifySub);\n    }\n    protected async _signinStart(args: CreateSigninRequestArgs, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signinStart\");\n\n        try {\n            const signinRequest = await this._client.createSigninRequest(args);\n            logger.debug(\"got signin request\");\n\n            return await handle.navigate({\n                url: signinRequest.url,\n                state: signinRequest.state.id,\n                response_mode: signinRequest.state.response_mode,\n                scriptOrigin: this.settings.iframeScriptOrigin,\n            });\n        }\n        catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n    protected async _signinEnd(url: string, verifySub?: string): Promise<User> {\n        const logger = this._logger.create(\"_signinEnd\");\n        const signinResponse = await this._client.processSigninResponse(url);\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse, verifySub);\n        return user;\n    }\n\n    protected async _buildUser(signinResponse: SigninResponse, verifySub?: string) {\n        const logger = this._logger.create(\"_buildUser\");\n        const user = new User(signinResponse);\n        if (verifySub) {\n            if (verifySub !== user.profile.sub) {\n                logger.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n                throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n            }\n            logger.debug(\"current user matches user returned from signin\");\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        this._events.load(user);\n\n        return user;\n    }\n\n    /**\n     * Returns promise to trigger a redirect of the current window to the end session endpoint.\n     */\n    public async signoutRedirect(args: SignoutRedirectArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signoutStart({\n            request_type: \"so:r\",\n            post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to process response from the end session endpoint.\n     */\n    public async signoutRedirectCallback(url = window.location.href): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"signoutRedirectCallback\");\n        const response = await this._signoutEnd(url);\n        logger.info(\"success\");\n        return response;\n    }\n\n    /**\n     * Returns promise to trigger a redirect of a popup window window to the end session endpoint.\n     */\n    public async signoutPopup(args: SignoutPopupArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutPopup\");\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_post_logout_redirect_uri;\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget });\n        await this._signout({\n            request_type: \"so:p\",\n            post_logout_redirect_uri: url,\n            // we're putting a dummy entry in here because we\n            // need a unique id from the state for notification\n            // to the parent window, which is necessary if we\n            // plan to return back to the client after signout\n            // and so we can close the popup after signout\n            state: url == null ? undefined : {},\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to process response from the end session endpoint from a popup window.\n     */\n    public async signoutPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signoutPopupCallback\");\n        await this._popupNavigator.callback(url, keepOpen);\n        logger.info(\"success\");\n    }\n\n    protected async _signout(args: CreateSignoutRequestArgs, handle: IWindow): Promise<SignoutResponse> {\n        const navResponse = await this._signoutStart(args, handle);\n        return await this._signoutEnd(navResponse.url);\n    }\n    protected async _signoutStart(args: CreateSignoutRequestArgs = {}, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signoutStart\");\n\n        try {\n            const user = await this._loadUser();\n            logger.debug(\"loaded current user from storage\");\n\n            if (this.settings.revokeTokensOnSignout) {\n                await this._revokeInternal(user);\n            }\n\n            const id_token = args.id_token_hint || user && user.id_token;\n            if (id_token) {\n                logger.debug(\"setting id_token_hint in signout request\");\n                args.id_token_hint = id_token;\n            }\n\n            await this.removeUser();\n            logger.debug(\"user removed, creating signout request\");\n\n            const signoutRequest = await this._client.createSignoutRequest(args);\n            logger.debug(\"got signout request\");\n\n            return await handle.navigate({\n                url: signoutRequest.url,\n                state: signoutRequest.state?.id,\n            });\n        }\n        catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n    protected async _signoutEnd(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"_signoutEnd\");\n        const signoutResponse = await this._client.processSignoutResponse(url);\n        logger.debug(\"got signout response\");\n\n        return signoutResponse;\n    }\n\n    /**\n     * Returns promise to trigger a silent request (via an iframe) to the end session endpoint.\n     */\n    public async signoutSilent(args: SignoutSilentArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n\n        const id_token_hint = this.settings.includeIdTokenInSilentSignout\n            ? (await this._loadUser())?.id_token\n            : undefined;\n\n        const url = this.settings.popup_post_logout_redirect_uri;\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        await this._signout({\n            request_type: \"so:s\",\n            post_logout_redirect_uri: url,\n            id_token_hint: id_token_hint,\n            ...requestArgs,\n        }, handle);\n\n        logger.info(\"success\");\n    }\n\n    /**\n     * Returns promise to notify the parent window of response from the end session endpoint.\n     */\n    public async signoutSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signoutSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    public async revokeTokens(types?: RevokeTokensTypes): Promise<void> {\n        const user = await this._loadUser();\n        await this._revokeInternal(user, types);\n    }\n\n    protected async _revokeInternal(user: User | null, types = this.settings.revokeTokenTypes): Promise<void> {\n        const logger = this._logger.create(\"_revokeInternal\");\n        if (!user) return;\n\n        const typesPresent = types.filter(type => typeof user[type] === \"string\");\n\n        if (!typesPresent.length) {\n            logger.debug(\"no need to revoke due to no token(s)\");\n            return;\n        }\n\n        // don't Promise.all, order matters\n        for (const type of typesPresent) {\n            await this._client.revokeToken(\n                user[type]!, // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                type,\n            );\n            logger.info(`${type} revoked successfully`);\n            if (type !== \"access_token\") {\n                user[type] = null as never;\n            }\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        this._events.load(user);\n    }\n\n    /**\n     * Enables silent renew for the `UserManager`.\n     */\n    public startSilentRenew(): void {\n        this._logger.create(\"startSilentRenew\");\n        void this._silentRenewService.start();\n    }\n\n    /**\n     * Disables silent renew for the `UserManager`.\n     */\n    public stopSilentRenew(): void {\n        this._silentRenewService.stop();\n    }\n\n    protected get _userStoreKey(): string {\n        return `user:${this.settings.authority}:${this.settings.client_id}`;\n    }\n\n    protected async _loadUser(): Promise<User | null> {\n        const logger = this._logger.create(\"_loadUser\");\n        const storageString = await this.settings.userStore.get(this._userStoreKey);\n        if (storageString) {\n            logger.debug(\"user storageString loaded\");\n            return User.fromStorageString(storageString);\n        }\n\n        logger.debug(\"no user storageString\");\n        return null;\n    }\n\n    public async storeUser(user: User | null): Promise<void> {\n        const logger = this._logger.create(\"storeUser\");\n        if (user) {\n            logger.debug(\"storing user\");\n            const storageString = user.toStorageString();\n            await this.settings.userStore.set(this._userStoreKey, storageString);\n        }\n        else {\n            this._logger.debug(\"removing user\");\n            await this.settings.userStore.remove(this._userStoreKey);\n        }\n    }\n\n    /**\n     * Removes stale state entries in storage for incomplete authorize requests.\n     */\n    public async clearStaleState(): Promise<void> {\n        await this._client.clearStaleState();\n    }\n}\n","// @ts-expect-error avoid enabling resolveJsonModule to keep build process simple\nimport { version } from \"../package.json\";\n\n/**\n * @public\n */\nexport const Version: string = version;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}